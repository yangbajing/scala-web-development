{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"Scala Web 开发——基于Akka HTTP"},{"location":"/index.html#scala-web-开发-基于akka-http","text":"Akka HTTP\n前言 作者 Scala 环境配置 Sbt 安装 Sbt 创建一个 Sbt 项目 多项目工程 IDE开发工具 导入 Sbt 工程 小结 Scala 语言基础 REPL 你好，Scala Scala基础 变量、基础数据类型 运算符和命名 流程和函数 控制语句（表达式） 集合 class和object Class object 函数式 函数 模式匹配（match case） Trait 并发 小结 Akka HTTP 基础 Akka HTTP 基础 Web 工作方式 使用 Akka Http 搭建一个简单的 Web 服务 第一个服务 Route JSON Route类型 Akka HTTP 的通用抽象 HTTP Model URI Model Marshalling Unmarshalling Encoding / Decoding JSON Support XML Support Akka HTTP Timeouts 小结 服务端API Akka HTTP 如何使得 Web 工作 启动和停止 请求、响应生命周期 错误处理 高级服务端 API 路由DSL Route 路由 RequestContext RouteResult 组合路由 路由树 Directive 指令 指令基础 指令可以做什么？ 组合指令 使用concat来连接多个指令 类型安全的指令 指令类型参数里的 Tuple （自动拉平 flattening） 自定义指令 命名配置 转换已存在的指令 从头开始实现一个指令 拒绝 rejections 异常处理 实战：大文件断点上传、下载和秒传 断点下载 断点上传 秒传 运行示例 小结 常用指令 PathDirectives（路径指令） Path示例 深入Uri.Path 深入PathMatcher directives/method.html directives/parameter_form.html directives/marshalling.html directives/file.html directives/cookie.html 数据 数据 JSON Jackson JacksonSupport 在 routing DSL 里使用 总结 实战：为Ant Design Pro提供后端接口 设置 Ant Design Pro 打包、部署 总结 Kryo Protobuf 小结 测试 测试 Scalatest 安装 ScalaTest 第一个测试用例 使用 Matchers OptionValues ScalaFutures Mock 测试异步代码 端到端测试Route Akka HTTP akka-http-testkit OrgRouteTest 总结 小结 实战：实现OAuth 2服务 实战：OAuth 2 服务 OAuth 2是如何工作的 为什么是JWT OAuth 2简介 OAuth 2 模式 OAuth 2接口设计 OAuth 2 API接口 OAuth 2服务实现 小结 访问数据库 访问数据库 使用 JDBC 访问 PostgreSQL PostgreSQL 访问数据库 使用 Slick 访问数据库 访问 Cassandra 数据库 Cassandra 数据模型 安装、配置 Cassandra Alpakka Cassandra Connector 访问 Redis 安装 添加库依赖 访问 Elasticsearch 安装 添加库依赖 小结 工程化 使用Swagger编写API文档 使用Guice管理类依赖 JSR-330 附录 参考资料 专业术语 词汇表 赞助","title":"Scala Web 开发——基于Akka HTTP"},{"location":"/preface.html","text":"","title":"前言"},{"location":"/preface.html#前言","text":"本书将主要基于 Akka HTTP 介绍怎样使用 Scala 进行 Web 开发。\nScala\nScala是一个面向对象的函数式特性编程语言，它继承了Java的面向对特性，同时又从Haskell等其它语言那里吸收了很多函数式特性并做了增强。\nAkka\nAkka 是一个在 JVM 上构建高并发、分布式、弹性的消息驱动应用程序的工具包。它使创建强大并发且具有分布式特性的应用程序更轻松：\nSimple Concurrency & Distribution（易使用的并发与分布式）： 异步和分布式设计，具有 Actors、Streams 和 Futures 等高级抽象。 Resilient By Design（弹性设计）： 编写具有自我修复特性的程序，完整的本地和远程监控层次。li High Performance（高性能）： 单机每秒 5000万 吞吐。较优的内存使用：每 1GB 堆内在可生成约 250万 个 actor。 Elastic & Decentralized（弹性和去中心化）： 自适应的集群管理、负载均衡、路由、分区和分版。 Extensible（可扩展）： 使用 Akka Extensions 来扩展 Akka ，以满足你的需要。\nAkka HTTP\nAkka HTTP 基于 akka-actor 和 akka-stream 完整实现了 HTTP 服务器和客户端协议。它不是一个 Web框架，而是一个更通用的工具包。\n本书源码在：\nhttps://github.com/yangbajing/scala-web-development http://git.oschina.net/yangbajing/scala-web-development\n有问题、建议请到 https://github.com/yangbajing/scala-web-development/issues 提供指导。","title":"前言"},{"location":"/preface.html#作者","text":"作者：杨景（羊八井） 邮箱：yangbajing at gmail com Weibo: @yangbajing 主页：https://www.yangbajing.me 微信公众号：yangbajing-garden","title":"作者"},{"location":"/env/index.html","text":"","title":"Scala 环境配置"},{"location":"/env/index.html#scala-环境配置","text":"http://scala-lang.org/download/ 安装标准 Scala 开发包。\nSbt 安装 Sbt 创建一个 Sbt 项目 多项目工程 IDE开发工具 导入 Sbt 工程 小结","title":"Scala 环境配置"},{"location":"/env/env.1.html","text":"","title":"Sbt"},{"location":"/env/env.1.html#sbt","text":"Scala有一套官方的编译、构建工具 Sbt，全称：The interactive build tool （交互构建工具）。它除了能做向 Maven、Gradle类似的 事情以外，它还有一个交互式的环境，可以在里面执行一些常用命令，甚至直接执行、测试代码。","title":"Sbt"},{"location":"/env/env.1.html#安装-sbt","text":"详细安装教程请阅读官方文档：https://www.scala-sbt.org/1.x/docs/index.html\nLinux/Unix/Mac\n下载安装并配置Sbt：\nwget -c https://github.com/sbt/sbt/releases/download/v1.2.8/sbt-1.2.8.tgz\ntar zxf sbt-1.2.8.tgz\necho 'export SBT_HOME=\"/home/yangjing/sbt-1.2.8\"\nexport PATH=\"$SBT_HOME/bin:$PATH\"\n' >> ~/.bash_profile\n. ~/.bash_profile\n现在可以在当前终端执行 sbt 命令了，若在重启系统前需要在其它终端也运行 sbt 命令，需要执行 . ~/.bash_profile 以使环 境变量生效。\nWindows\n下载 https://github.com/sbt/sbt/releases/download/v1.2.8/sbt-1.2.8.msi ，双击安装。","title":"安装 Sbt"},{"location":"/env/env.1.html#创建一个-sbt-项目","text":"创建一个 Sbt 还是比较简单的，你可以从使用 sbt new 命令从线上众多的模板开始，也可以手动创建。\nsbt new\nsbt new scala/scala-seed.g8\n\nMinimum Scala build. \n\nname [My Something Project]: scala-seed\n当前目录下多了个 scala-seed 目录，通过 sbt new 创建的项目里面的 Scala 版本可能不是你想要的。不过在这里不用担心，保持默认即可。（本书 将基于 Scala 2.12.x 讲解）。\nSbt 控制台\nSbt 是一个交互式的构建工具，它具有一个 REPL 的命令行控制台，你可以在里面编译、运行、测试，甚至打包及执行自定义命令……\n[yangjing@yangjing-31 scala-seed-project]$ /usr/bin/sbt\n[info] Loading settings from idea.sbt ...\n[info] Loading global plugins from /opt/local/share/sbt/1.0/plugins\n[info] Loading project definition from /tmp/scala-seed-project/project\n[info] Loading settings from build.sbt ...\n[info] Set current project to Scala Seed Project (in build file:/tmp/scala-seed-project/)\n[info] sbt server started at local:///home/yangjing/.sbt/1.0/server/d42fb1897d8aa6920ae0/sock\nsbt:Scala Seed Project>\n运行示例程序\n运行 scalatest 测试","title":"创建一个 Sbt 项目"},{"location":"/env/env.1.html#多项目工程","text":"通常在真实的应用开发中，我们都会在一个工程里有多个子项目，使用子项目的形式来区分不同模块。我们只需要在 build.sbt 工程配置文件中使用 project 指令来定义不同的子项目即可，一个示例如下：\nname in Global := \"multi-project\"\n\norganization in Global := \"me.yangbajing\"\n\nversion in Global := \"0.0.1\"\n\nscalaVersion in Global := \"2.12.8\"\n\nlazy val `multi-project-root` = project.in(file(\".\"))\n  .aggregate(app)\n\nlazy val app = project\n  .dependsOn(common)\n\nlazy val common = project\n  .settings(\n    libraryDependencies += \"org.scalatest\" %% \"scalatest\" % \"3.0.5\" % Test\n  )\nproject：需要传入一个File参数，用于设置子项目的本地路径。 aggregate：根项目中用于聚合需要的子项目。在Sbt控制台不进入子项目的情况下使用compile、test等命令时会依次进入所有配置了的子项目执行命令。 dependsOn：指定依赖的项目。 settings：对应单项目配置时的配置项都在此设置。\n多项目工程目录结构如下：\n├── app\n│   ├── src\n│   │   ├── main\n│   │   └── test\n├── common\n│   ├── src\n│   │   ├── main\n│   │   └── test\n├── project\n│   ├── build.properties\n├── build.sbt\n注意 默认，sbt不会创建src/main/scala、src/test/scala等相关源码目录，这需要我们手动创建。","title":"多项目工程"},{"location":"/env/env.2.html","text":"","title":"IDE开发工具"},{"location":"/env/env.2.html#ide开发工具","text":"推荐使用 Jetbrains IDEA 进行Scala开发，请到官网 https://www.jetbrains.com/idea/ 下载。\n我们需要安装 Scala 插件。","title":"IDE开发工具"},{"location":"/env/env.2.html#导入-sbt-工程","text":"导入 Sbt 工程非常的简单，使用 IDEA 直接打开工程目录即可（需要注意选择：Sbt项目）。\n选中目录后，IDEA 将开始导入工程，这里你可以对导入选项做一些自定义。","title":"导入 Sbt 工程"},{"location":"/env/env.z.html","text":"","title":"小结"},{"location":"/env/env.z.html#小结","text":"本章介绍了怎样安装 Sbt 和 IDEA 作为 Scala 的开发环境，并介绍了怎样新建一个 Sbt 工程和怎样将一个 Sbt 工程导入到IDEA中。\n接下来，我们将正式进入 Scala 的世界。","title":"小结"},{"location":"/scala/index.html","text":"","title":"Scala 语言基础"},{"location":"/scala/index.html#scala-语言基础","text":"REPL 你好，Scala Scala基础 变量、基础数据类型 运算符和命名 流程和函数 控制语句（表达式） 集合 class和object Class case class（样本类） object 伴身对象 函数式 函数 一个函数示例：自动资源管理 模式匹配（match case） match 中的值、变量和类型 序列的匹配 case class的匹配 Trait 并发 小结","title":"Scala 语言基础"},{"location":"/scala/scala.0.html","text":"","title":"REPL"},{"location":"/scala/scala.0.html#repl","text":"有两种启动 REPL 的方式，一种是直接运行 scala 命令：\ncd $SCALA_HOME\n./bin/scala\n还有种是在 Sbt工程登录进入 Sbt Console：\nsbt console\n或者在进入 Sbt 交互式控制台后再执行 console 命令。\n启动Scala REPL，它是一个基于命令行的交互式编程环境。对于有着Python、Ruby等动态语言的同学来说，这是一个很常用和工具。但Javaer 们第一次见到会觉得比较神奇。我们可以在REPL中做一些代码尝试而不用启动笨拙的IDE，这在我们思考问题时非常的方便。对于Javaer有一个好消息，JDK 9开 始将内建支持REPL功能。\nsbt:scala-seed> console\n[info] Starting scala interpreter...\nWelcome to Scala 2.12.4 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_151).\nType in expressions for evaluation. Or try :help.\n\nscala>\n接下来我们将在 Scala REPL 中测试本章的示例代码。","title":"REPL"},{"location":"/scala/scala.1.html","text":"","title":"你好，Scala"},{"location":"/scala/scala.1.html#你好-scala","text":"Scala 是一门表达力很强的语言，它可以成为你工作中优秀的助手。不免俗，我们来看看 Scala 里的 helloworld：\nprintln(\"你好，Scala！\")\n将代码保存为 helloworld.scala 文件，在命令行使用以下命令直接运行（你也可以在 REPL 中直接输入上面代码运行）。：\n$ scala helloworld.scala\n$ 你好，Scala！\nScala 可以直接执行代码文件，这个特性可以让我们使用 Scala 来写系统脚本（虽然实践中我还没这么做，因为Scala的编译、启动还是比较慢的）。我们可以 看到，代码中使用了 println 函数来输出字符串，这其实是对 java.lang.System.out.println 的封装。","title":"你好，Scala"},{"location":"/scala/scala.2.html","text":"","title":"Scala基础"},{"location":"/scala/scala.2.html#scala基础","text":"","title":"Scala基础"},{"location":"/scala/scala.2.html#变量-基础数据类型","text":"Scala中变量不需要显示指定类型，但需要提前声明。这可以避免很多命名空间污染问题。Scala有一个很强大的类型自动推导功能，它可以根据右值及上下文自动推导出变量的类型。你可以通过如下方式来直接声明并赋值。\nscala> val a = 1\na: Int = 1\n\nscala> val b = true\nb: Boolean = true\n\nscala> val c = 1.0\nc: Double = 1.0\n\nscala> val a = 30 + \"岁\"\na: String = 30岁\nImmutable\n（注：函数式编程有一个很重要的特性：不可变性。Scala中除了变量的不可变性，它还定义了一套不可变集合scala.collection.immutable._。）\nval代表这是一个final variable，它是一个常量。定义后就不可以改变，相应的，使用var定义的就是平常所见的变量了，是可以改变的。从终端的打印可以看出，Scala从右值自动推导出了变量的类型。Scala可以如动态语言似的编写代码，但又有静态语言的编译时检查。这对于Java中冗长、重复的类型声明来说是一种很好的进步。\n（注：在REPL中，val变量是可以重新赋值的，这是｀REPL`的特性。在平常的代码中是不可以的。）\n基础数据类型\nScala中基础数据类型有：Byte、Short、Int、Long、Float、Double，Boolean，Char、String。和Java不同的是，Scala中没在区分原生类型和装箱类型，如：int和Integer。它统一抽象成Int类型，这样在Scala中所有类型都是对象了。编译器在编译时将自动决定使用原生类型还是装箱类型。\n字符串\nScala中的字符串有3种。\n分别是普通字符串，它的特性和Java字符串一至。 连线3个双引号在Scala中也有特殊含义，它代表被包裹的内容是原始字符串，可以不需要字符转码。这一特性在定义正则表达式时很有优势。 还有一种被称为“字符串插值”的字符串，他可以直接引用上下文中的变量，并把结果插入字符串中。\nscala> val c2 = '杨'\nc2: Char = 杨\n\nscala> val s1 = \"羊八井花园\"\ns1: String = 羊八井花园\n\nscala> val s2 = s\"羊八井花园${c2}景\"\ns2: String = 羊八井花园\n\nscala> val s3 = s\"\"\"羊八井花园\"工程师\"\\n${c2}景是江津人\"\"\"\ns3: String =\n羊八井花园\"工程师\"\n杨景是江津人","title":"变量、基础数据类型"},{"location":"/scala/scala.2.html#运算符和命名","text":"Scala中的运算符其实是定义在对象上的方法（函数），你看到的诸如：3 + 2其实是这样子的：3.+(2)。+符号是定义在Int对象上的一个方法。支持和Java一至的运算符（方法）：\n（注：在Scala中，方法前的.号和方法两边的小括号在不引起歧义的情况下是可以省略的。这样我们就可以定义出很优美的DSL）\n==、!=：比较运算 !、|、&、^：逻辑运算 >>、<<：位运算\n注意\n在Scala中，修正了（算更符合一般人的常规理解吧）==和!=运算符的含义。在Scala中，==和!=是执行对象的值比较，相当于Java中的equals方法（实际上编译器在编译时也是这么做的）。而对象的引用比较需要使用eq和ne两个方法来实现。","title":"运算符和命名"},{"location":"/scala/scala.3.html","text":"","title":"流程和函数"},{"location":"/scala/scala.3.html#流程和函数","text":"","title":"流程和函数"},{"location":"/scala/scala.3.html#控制语句-表达式-","text":"Scala中支持if、while、for comprehension（for表达式)、match case（模式匹配）四大主要控制语句。Scala不支持switch和? :两种控制语句，但它的if和match case会有更好的实现。\nif\nScala支持if语句，其基本使用和Java、Python中的一样。但不同的时，它是有返回值的。\n（注：Scala是函数式语言，函数式语言还有一大特性就是：表达式。函数式语言中所有语句都是基于“表达式”的，而“表达式”的一个特性就是它会有一个值。所有像Java中的? :3目运算符可以使用if语句来代替）。\nscala> if (true) \"真\" else \"假\"\nres0: String = 真\n\nscala> val f = if (false) \"真\" else \"假\"\nf: String = 假\n\nscala> val unit = if (false) \"真\"\nunit: Any = ()\n\nscala> val unit2 = if (true) \"真\" \nunit2: Any = 真\n可以看到，if语句也是有返回值的，将表达式的结果赋给变量，编译器也能正常推导出变量的类型。unit和unit2变量的类型是Any，这是因为else语句的缺失，Scala编译器就按最大化类型来推导，而Any类型是Scala中的根类型。()在Scala中是Unit类型的实例，可以看做是Java中的Void。\nwhile\nScala中的while循环语句：\nwhile (条件) {\n  语句块\n}\nfor comprehension\nScala中也有for表达式，但它和Java中的for不太一样，它具有更强大的特性。通常的for语句如下：\nfor (变量 <- 集合) {\n  语句块\n}\nScala中for表达式除了上面那样的常规用法，它还可以使用yield关键字将集合映射为另一个集合：\nscala> val list = List(1, 2, 3, 4, 5)\nlist: List[Int] = List(1, 2, 3, 4, 5)\n\nscala> val list2 = for (item <- list) yield item + 1\nlist2: List[Int] = List(2, 3, 4, 5, 6)\n还可以在表达式中使用if判断：\nscala> val list3 = for (item <- list if item % 2 == 0) yield item\nlist3: List[Int] = List(2, 4)\n还可以做flatMap操作，解析2维列表并将结果摊平（将2维列表拉平为一维列表）：\nscala> val llist = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))\nllist: List[List[Int]] = List(List(1, 2, 3), List(4, 5, 6), List(7, 8, 9))\n\nscala> for {\n     |   l <- llist\n     |   item <- l if item % 2 == 0\n     | } yield item\nres3: List[Int] = List(2, 4, 6, 8)\n看到了，Scala中for comprehension的特性是很强大的。Scala的整个集合库都支持这一特性，包括：Seq、Map、Set、Array……\nScala没有C-Like语言里的for (int i = 0; i < 10; i++)语法，但Range（范围这个概念），可以基于它来实现循环迭代功能。在Scala中的使用方式如下：\nscala> for (i <- (0 until 10)) {\n     |   println(i)\n     | }\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\nScala中还有一个to方法：\nscala> for (i <- (0 to 10)) print(\" \" + i)\n 0 1 2 3 4 5 6 7 8 9 10\n你还可以控制每次步进的步长，只需要简单的使用by方法即可：\nscala> for (i <- 0 to 10 by 2) print(\" \" + i)\n 0 2 4 6 8 10\nmatch case\n模式匹配，是函数式语言很强大的一个特性。它比命令式语言里的switch更好用，表达性更强。\nscala> def level(s: Int) = s match {\n     |   case n if n >= 90 => \"优秀\"\n     |   case n if n >= 80 => \"良好\"\n     |   case n if n >= 70 => \"良\"\n     |   case n if n >= 60 => \"及格\"\n     |   case _ => \"差\"\n     | }\nlevel: (s: Int)String\n\nscala> level(51)\nres28: String = 差\n\nscala> level(93)\nres29: String = 优秀\n\nscala> level(80)\nres30: String = 良好\n可以看到，模式匹配可以实现switch相似的功能。但与switch需要使用break明确告知终止之后的判断不同，Scala中的match case是默认**break**的。只要其中一个case语句匹配，就终止之后的所以比较。且对应case语句的表达式值将作为整个match case表达式的值返回。\nScala中的模式匹配还有类型匹配、数据提取、谓词判断等其它有用的功能。这里只做简单介绍，之后会单独一个章节来做较详细的解读。","title":"控制语句（表达式）"},{"location":"/scala/scala.4.html","text":"","title":"集合"},{"location":"/scala/scala.4.html#集合","text":"在java.util包下有丰富的集合库。Scala除了可以使用Java定义的集合库外，它还自己定义了一套功能强大、特性丰富的scala.collection集合库API。\n在Scala中，常用的集合类型有：List、Set、Map、Tuple、Vector等。\nList\nScala中List是一个不可变列表集合，它很精妙的使用递归结构定义了一个列表集合。\nscala> val list = List(1, 2, 3, 4, 5)\nlist: List[Int] = List(1, 2, 3, 4, 5)\n除了之前使用Listobject来定义一个列表，还可以使用如下方式：\nscala> val list = 1 :: 2 :: 3 :: 4 :: 5 :: Nil\nlist: List[Int] = List(1, 2, 3, 4, 5)\nList采用前缀操作的方式（所有操作都在列表顶端（开头））进行，::操作符的作用是将一个元素和列表连接起来，并把元素放在列表的开头。这样List的操作就可以定义成一个递归操作。添加一个元素就是把元素加到列表的开头，List只需要更改下头指针，而删除一个元素就是把List的头指针指向列表中的第2个元素。这样，List的实现就非常的高效，它也不需要对内存做任何的转移操作。List有很多常用的方法：\nscala> list.indexOf(3)\nres6: Int = 2\n\nscala> 0 :: list\nres8: List[Int] = List(0, 1, 2, 3, 4, 5)\n\nscala> list.reverse\nres9: List[Int] = List(5, 4, 3, 2, 1)\n\nscala> list.filter(item => item == 3)\nres11: List[Int] = List(3)\n\nscala> list\nres12: List[Int] = List(1, 2, 3, 4, 5)\n\nscala> val list2 = List(4, 5, 6, 7, 8, 9)\nlist2: List[Int] = List(4, 5, 6, 7, 8, 9)\n\nscala> list.intersect(list2)\nres13: List[Int] = List(4, 5)\n\nscala> list.union(list2)\nres14: List[Int] = List(1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9)\n\nscala> list.diff(list2)\nres15: List[Int] = List(1, 2, 3)\nScala中默认都是**Immutable collection**，在集合上定义的操作都不会更改集合本身，而是生成一个新的集合。这与Java集合是一个根本的区别，Java集合默认都是可变的。\nTuple\nScala中也支持**Tuple**（元组）这种集合，但最多只支持22个元素（事实上Scala中定义了Tuple0、Tuple1……Tuple22这样22个TupleX类，实现方式与C++ Boost库中的Tuple类似）。和大多数语言的Tuple类似（比如：Python），Scala也采用小括号来定义元组。\nscala> val tuple3 = (1, 2, 3)\ntuple1: (Int, Int, Int) = (1,2,3)\n\nscala> tuple3._2\nres17: Int = 2\n\nscala> val tuple2 = Tuple2(\"杨\", \"景\")\ntuple2: (String, String) = (杨,景)\n可以使用xxx._[X]的形式来引用Tuple中某一个具体元素，其_[X]下标是从1开始的，一直到22（若有定义这么多）。\nSet\nSet是一个不重复且无序的集合，初始化一个Set需要使用Set对象：\nscala> val set = Set(\"Scala\", \"Java\", \"C++\", \"Javascript\", \"C#\", \"Python\", \"PHP\") \nset: scala.collection.immutable.Set[String] = Set(Scala, C#, Python, Javascript, PHP, C++, Java)\n\nscala> set + \"Go\"\nres21: scala.collection.immutable.Set[String] = Set(Scala, C#, Go, Python, Javascript, PHP, C++, Java)\n\nscala> set filterNot (item => item == \"PHP\")\nres22: scala.collection.immutable.Set[String] = Set(Scala, C#, Python, Javascript, C++, Java)\nMap\nScala中的Map默认是一个**HashMap**，其特性与Java版的HashMap基本一至，除了它是Immutable的：\nscala> val map = Map(\"a\" -> \"A\", \"b\" -> \"B\")\nmap: scala.collection.immutable.Map[String,String] = Map(a -> A, b -> B)\n\nscala> val map2 = Map((\"b\", \"B\"), (\"c\", \"C\"))\nmap2: scala.collection.immutable.Map[String,String] = Map(b -> B, c -> C)\nScala中定义Map时，传入的每个Entry（**K**、**V**对）其实就是一个Tuple2（有两个元素的元组），而->是定义Tuple2的一种便捷方式。\nscala> map + (\"z\" -> \"Z\")\nres23: scala.collection.immutable.Map[String,String] = Map(a -> A, b -> B, z -> Z)\n\nscala> map.filterNot(entry => entry._1 == \"a\")\nres24: scala.collection.immutable.Map[String,String] = Map(b -> B)\n\nscala> val map3 = map - \"a\"\nmap3: scala.collection.immutable.Map[String,String] = Map(b -> B)\n\nscala> map\nres25: scala.collection.immutable.Map[String,String] = Map(a -> A, b -> B)\nScala的immutable collection并没有添加和删除元素的操作，其定义+（List使用::在头部添加）操作都是生成一个新的集合，而要删除一个元素一般使用 - 操作直接将**Key**从map中减掉即可。\n（注：Scala中也scala.collection.mutable._集合，它定义了不可变集合的相应可变集合版本。一般情况下，除非一此性能优先的操作（其实Scala集合采用了共享存储的优化，生成一个新集合并不会生成所有元素的复本，它将会和老的集合共享大元素。因为Scala中变量默认都是不可变的），推荐还是采用不可变集合。因为它更直观、线程安全，你可以确定你的变量不会在其它地方被不小心的更改。）","title":"集合"},{"location":"/scala/scala.5.html","text":"","title":"class和object"},{"location":"/scala/scala.5.html#class和object","text":"","title":"class和object"},{"location":"/scala/scala.5.html#class","text":"Scala里也有class关键字，不过它定义类的方式与Java有些区别。Scala中，类默认是 public 的，且类属性和方法默认也是 public 的。Scala中，每个类都有一个 主构造函数 ，主构造函数类似函数参数一样写在类名后的小括号中。因为Scala没有像Java那样的“构造函数”，所以属性变量都会在类被创建后初始化。所以当你需要在构造函数里初始化某些属性或资源时，写在类中的属性变量就相当于构造初始化了。\n在Scala中定义类非常简单：\nclass Person(name: String, val age: Int) {\n  override def toString(): String = s\"姓名：$name, 年龄: $age\"\n}\n默认，Scala主构造函数定义的属性是 private 的，可以显示指定：val或var来使其可见性为： public 。\nScala中覆写一个方法必需添加：override关键字，这对于Java来说可以是一个修正。当标记了override关键字的方法在编译时，若编译器未能在父类中找到可覆写的方法时会报错。而在Java中，你只能通过@Override注解来实现类似功能，它的问题是它只是一个可选项，且编译器只提供警告。这样你还是很容易写出错误的“覆写”方法，你以后覆写了父类函数，但其实很有可能你是实现了一个新的方法，从而引入难以察觉的BUG。\n实例化一个类的方式和Java一样，也是使用new关键字。\nscala> val me = new Person(\"杨景\", 30)\nme: Person = 姓名：杨景, 年龄: 30\n\nscala> println(me)\n姓名：杨景, 年龄: 30\n\nscala> me.name\n<console>:20: error: value name is not a member of Person\n       me.name\n          ^\n\nscala> me.age\nres11: Int = 30","title":"Class"},{"location":"/scala/scala.5.html#case-class-样本类-","text":"case class是Scala中学用的一个特性，像Kotlin这样的语言也学习并引入了类似特性（在Kotlin中叫做：data class）。case class具有如下特性：\n不需要使用new关键词创建，直接使用类名即可 默认变量都是**public final**的，不可变的。当然也可以显示指定var、private等特性，但一般不推荐这样用 自动实现了：equals、hashcode、toString等函数 自动实现了：Serializable接口，默认是可序列化的 可应用到**match case**（模式匹配）中 自带一个copy方法，可以方便的根据某个case class实例来生成一个新的实例 ……\n这里给出一个case class的使用样例：\nscala> trait Person\ndefined trait Person\n\nscala> case class Man(name: String, age: Int) extends Person\ndefined class Man\n\nscala> case class Woman(name: String, age: Int) extends Person\ndefined class Woman\n\nscala> val man = Man(\"杨景\", 30)\nman: Man = Man(杨景,30)\n\nscala> val woman = Woman(\"女人\", 23)\nwoman: Woman = Woman(女人,23)\n\nscala> val manNextYear = man.copy(age = 31)\nmanNextYear: Man = Man(杨景,31)","title":"case class（样本类）"},{"location":"/scala/scala.5.html#object","text":"Scala有一种不同于Java的特殊类型，**Singleton Objects**。\nobject Blah {\n  def sum(l: List[Int]): Int = l.sum\n}\n在Scala中，没有Java里的**static**静态变量和静态作用域的概念，取而代之的是：**object**。它除了可以实现Java里**static**的功能，它同时还是一个线程安全的单例类。","title":"object"},{"location":"/scala/scala.5.html#伴身对象","text":"大多数的object都不是独立的，通常它都会与一个同名的class定义在一起。这样的object称为**伴身对象**。\nclass IntPair(val x: Int, val y: Int)\n\nobject IntPair {\n  import math.Ordering\n  implicit def ipord: Ordering[IntPair] =\n    Ordering.by(ip => (ip.x, ip.y))\n}\n注意 伴身对象必需和它关联的类定义在同一个 .scala 文件。\n伴身对象和它相关的类之间可以相互访问受保护的成员。在Java程序中，很多时候会把 static 成员设置成 private 的，在Scala中需要这样实现此特性：\nclass X {\n  import X._\n  def blah = foo\n}\nobject X {\n  private def foo = 42\n}","title":"伴身对象"},{"location":"/scala/scala.6.html","text":"","title":"函数式"},{"location":"/scala/scala.6.html#函数式","text":"","title":"函数式"},{"location":"/scala/scala.6.html#函数","text":"在Scala中，函数是一等公民。函数可以像类型一样被赋值给一个变量，也可以做为一个函数的参数被传入，甚至还可以做为函数的返回值返回。\n从Java 8开始，Java也具备了部分函数式编程特性。其Lamdba函数允许将一个函数做值赋给变量、做为方法参数、做为函数返回值。\n在Scala中，使用def关键词来定义一个函数方法：\nscala> def calc(n1: Int, n2: Int): (Int, Int) = {\n     |   (n1 + n2, n1 * n2)\n     | }\ncalc: (n1: Int, n2: Int)(Int, Int)\n\nscala> val (add, sub) = calc(5, 1)\nadd: Int = 6\nsub: Int = 5\n这里定义了一个函数：calc，它有两个参数：n1和n2，其类型为：Int。cala函数的返回值类型是一个有两个元素的元组，在Scala中可以简写为：(Int, Int)。在Scala中，代码段的最后一句将做为函数返回值，所以这里不需要显示的写return关键字。\n而val (add, sub) = calc(5, 1)一句，是Scala中的提取功能。它直接把calc函数返回的一个Tuple2值赋给了add他sub两个变量。\n函数可以赋给变量：\nscala> val calcVar = calc _\ncalcVar: (Int, Int) => (Int, Int) = <function2>\n\nscala> calcVar(2, 3)\nres4: (Int, Int) = (5,6)\n\nscala> val sum: (Int, Int) => Int = (x, y) => x + y\nsum: (Int, Int) => Int = <function2>\n\nscala> sum(5, 7)\nres5: Int = 12\n在Scala中，有两种定义函数的方式：\n将一个现成的函数/方法赋值给一个变量，如：val calcVar = calc _。下划线在此处的含意是将函数赋给了变量，函数本身的参数将在变量被调用时再传入。 直接定义函数并同时赋给变量，如：val sum: (Int, Int) => Int = (x, y) => x + y，在冒号之后，等号之前部分：(Int, Int) => Int是函数签名，代表sum这个函数值接收两个Int类型参数并返回一个Int类型参数。等号之后部分是函数体，在函数函数时，x、y参数类型及返回值类型在此可以省略。","title":"函数"},{"location":"/scala/scala.6.html#一个函数示例-自动资源管理","text":"在我们的日常代码中，资源回收是一个很常见的操作。在Java 7之前，我们必需写很多的try { ... } finally { xxx.close() }这样的样版代码来手动回收资源。Java 7开始，提供了**try with close**这样的自动资源回收功能。Scala并不能使用Java 7新加的**try with close**资源自动回收功能，但Scala中有很方便的方式实现类似功能：\ndef using[T <: AutoCloseable, R](res: T)(func: T => R): R = {\n  try {\n    func(res)\n  } finally {\n    if (res != null)\n      res.close()\n  }\n}\n\nval allLine = using(Files.newBufferedReader(Paths.get(\"/etc/hosts\"))) { reader =>\n  @tailrec\n  def readAll(buffer: StringBuilder, line: String): String = {\n    if (line == null) buffer.toString\n    else {\n      buffer.append(line).append('\\n')\n      readAll(buffer, reader.readLine())\n    }\n  }\n  \n  readAll(new StringBuilder(), reader.readLine())\n}\n\nprintln(allLine)\nusing是我们定义的一个自动化资源管帮助函数，它接爱两个参数化类型参数，一个是实现了AutoCloseable接口的资源类，一个是形如：T => R的函数值。func是由用户定义的对res进行操作的函数代码体，它将被传给using函数并由using代执行。而res这个资源将在using执行完成返回前调用finally代码块执行.close方法来清理打开的资源。\n这个：T <: AutoCloseable范型参数限制了 T 类型必需为AutoCloseable类型或其子类。R范型指定using函数的返回值类型将在实际调用时被自动参数化推导出来。我们在 Scala Console 中参看allLine变量的类型可以看到 allLine将被正确的赋予 String 类型，因为我们传给using函数参数func的函数值返回类型就为 String ：\nscala> :type allLine\nString\n在readAll函数的定义处，有两个特别的地方：\n这个函数定义在了其它函数代码体内部 它有一个@tailrec注解\n在Scala中，因为函数是第一类的，它可以被赋值给一个变量。所以Scala中的def定义函数可以等价val func = (x: Int, y: Int) => x + y这个的函数字面量定义函数形式。所以，既然通过变量定义的函数可以放在其它函数代码体内，通过def定义的函数也一样可以放在其它代码体内，这和**Javascript**很像。\n@tailrec注解的含义是这个函数是尾递归函数，编译器在编译时将对其优化成相应的**while**循环。若一个函数不是尾递归的，加上此注解在编译时将报错。","title":"一个函数示例：自动资源管理"},{"location":"/scala/scala.6.html#模式匹配-match-case-","text":"模式匹配是函数式编程里面很强大的一个特性。\n之前已经见识过了模式匹配的简单使用方式，可以用它替代：**if else**、**switch**这样的分支判断。除了这些简单的功能，模式匹配还有一系列强大、易用的特性。","title":"模式匹配（match case）"},{"location":"/scala/scala.6.html#match-中的值-变量和类型","text":"scala> for {\n     |   x <- Seq(1, false, 2.7, \"one\", 'four, new java.util.Date(), new RuntimeException(\"运行时异常\"))\n     | } {\n     |   val str = x match {\n     |     case d: Double => s\"double: $d\"\n     |     case false => \"boolean false\"\n     |     case d: java.util.Date => s\"java.util.Date: $d\"\n     |     case 1 => \"int 1\"\n     |     case s: String => s\"string: $s\"\n     |     case symbol: Symbol => s\"symbol: $symbol\"\n     |     case unexpected => s\"unexpected value: $unexpected\"\n     |   }\n     |   println(str)\n     | }\nint 1\nboolean false\ndouble: 2.7\nstring: one\nsymbol: 'four\njava.util.Date: Sun Jul 24 16:51:20 CST 2016\nunexpected value: java.lang.RuntimeException: 运行时异常\n上面小试牛刀校验变量类型的同时完成类型转换功能。在Java中，你肯定写过或见过如下的代码：\npublic void receive(message: Object) {\n    if (message isInstanceOf String) {\n        String strMsg = (String) message;\n        ....\n    } else if (message isInstanceOf java.util.Date) {\n        java.util.Date dateMsg = (java.util.Date) message;\n        ....\n    } ....\n}\n对于这样的代码，真是辣眼睛啊~~~。","title":"match 中的值、变量和类型"},{"location":"/scala/scala.6.html#序列的匹配","text":"scala> val nonEmptySeq = Seq(1, 2, 3, 4, 5)\n\nscala> val emptySeq = Seq.empty[Int]\n\nscala> val emptyList = Nil\n\nscala> val nonEmptyList = List(1, 2, 3, 4, 5)\n\nscala> val nonEmptyVector = Vector(1, 2, 3, 4, 5)\n\nscala> val emptyVector = Vector.empty[Int]\n\nscala> val nonEmptyMap = Map(\"one\" -> 1, \"two\" -> 2, \"three\" -> 3)\n\nscala> val emptyMap = Map.empty[String, Int]\n\nscala> def seqToString[T](seq: Seq[T]): String = seq match {\n     |   case head +: tail => s\"$head +: \" + seqToString(tail)\n     |   case Nil => \"Nil\"\n     | }\n\nscala> for (seq <- Seq(\n     |   nonEmptySeq, emptySeq, nonEmptyList, emptyList,\n     |   nonEmptyVector, emptyVector, nonEmptyMap.toSeq, emptyMap.toSeq)) {\n     |   println(seqToString(seq))\n     | }\n1 +: 2 +: 3 +: 4 +: 5 +: Nil\nNil\n1 +: 2 +: 3 +: 4 +: 5 +: Nil\nNil\n1 +: 2 +: 3 +: 4 +: 5 +: Nil\nNil\n(one,1) +: (two,2) +: (three,3) +: Nil\nNil\n模式匹配能很方便的提取序列的元素，seqToString使用了模式匹配以递归的方式来将序列转换成字符串。case head +: tail将序列提取成“头部”和“非头部剩下”两部分，head将保存序列第一个元素，tail保存序列剩下部分。而case Nil将匹配一个空序列。","title":"序列的匹配"},{"location":"/scala/scala.6.html#case-class的匹配","text":"scala> trait Person\n\nscala> case class Man(name: String, age: Int) extends Person\n\nscala> case class Woman(name: String, age: Int) extends Person\n\nscala> case class Boy(name: String, age: Int) extends Person\n\nscala> val father = Man(\"父亲\", 33)\n\nscala> val mather = Woman(\"母亲\", 30)\n\nscala> val son = Man(\"儿子\", 7)\n\nscala> val daughter = Woman(\"女儿\", 3)\n\nscala> for (person <- Seq[Person](father, mather, son, daughter)) {\n     |   person match {\n     |     case Man(\"父亲\", age) => println(s\"父亲今年${age}岁\")\n     |     case man: Man if man.age < 10 => println(s\"man is $man\")\n     |     case Woman(name, 30) => println(s\"${name}今年有30岁\")\n     |     case Woman(name, age) => println(s\"${name}今年有${age}岁\")\n     |   }\n     | }\n父亲今年33岁\n母亲今年有30岁\nman is Man(儿子,7)\n女儿今年有3岁\n在模式匹配中对case class进行 解构 操作，可以直接提取出感兴趣的字段并赋给变量。同时，模式匹配中还可以使用 guard 语句，给匹配判断添加一个if表达式做条件判断。","title":"case class的匹配"},{"location":"/scala/scala.7.html","text":"","title":"Trait"},{"location":"/scala/scala.7.html#trait","text":"TODO","title":"Trait"},{"location":"/scala/scala.8.html","text":"","title":"并发"},{"location":"/scala/scala.8.html#并发","text":"Scala是对多核和并发编程的支付做得非常好，它的Future类型提供了执行异步操作的高级封装。\nFuture对象完成构建工作以后，控制权便会立刻返还给调用者，这时结果还不可以立刻可用。Future实例是一个句柄，它指向最终可用的结果值。不论操作成功与否，在future操作执行完成前，代码都可以继续执行而不被阻塞。Scala提供了多种方法用于处理future。\nscala> :paste\n// Entering paste mode (ctrl-D to finish)\n\nimport scala.concurrent.duration.Duration\nimport scala.concurrent.{Await, Future}\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nval futures = (0 until 10).map { i =>\n  Future {\n    val s = i.toString\n    print(s)\n    s\n  }\n}\n\nval future = Future.reduce(futures)((x, y) => x + y)\n\nval result = Await.result(future, Duration.Inf)\n\n// Exiting paste mode, now interpreting.\n\n0132564789\n\nscala> val result = Await.result(future, Duration.Inf)\nresult: String = 0123456789\n上面代码创建了10个Future对象，Future.apply方法有两个参数列表。第一个参数列表包含一个需要并发执行的命名方法体（by-name body）；而第二个参数列表包含了隐式的ExecutionContext对象，可以简单的把它看作一个线程池对象，它决定了这个任务将在哪个异步（线程）执行器中执行。futures对象的类型为IndexedSeq[Future[String]]。本示例中使用Future.reduce把一个futures的IndexedSeq[Future[String]]类型压缩成单独的Future[String]类型对象。Await.result用来阻塞代码并获取结果，输入的Duration.Inf用于设置超时时间，这里是无限制。\n这里可以看到，在Future代码内部的println语句打印输出是无序的，但最终获取的result结果却是有序的。这是因为虽然每个Future都是在线程中无序执行，但Future.reduce方法将按传入的序列顺序合并结果。\n除了使用Await.result阻塞代码获取结果，我们还可以使用事件回调的方式异步获取结果。Future对象提供了几个方法通过回调将执行的结果返还给调用者，常用的有：\nonComplete: PartialFunction[Try[T], Unit]：当任务执行完成后调用，无论成功还是失败 foreach: [U](f: T => U)：当任务成功执行完成后调用\nimport scala.concurrent.Future\nimport scala.util.{Failure, Success}\nimport scala.concurrent.ExecutionContext.Implicits.global\n\nval futures = (1 to 2) map {\n  case 1 => Future.successful(\"1是奇数\")\n  case 2 => Future.failed(new RuntimeException(\"2不是奇数\"))\n}\n\nfutures.foreach(_.onComplete {\n  case Success(i) => println(i)\n  case Failure(t) => println(t)\n})\n\nThread.sleep(2000)\nfutures.onComplete方法是一个偏函数，它的参数是：Try[String]。Try有两个子类，成功是返回Success[String]，失败时返回Failure[Throwable]，可以通过模式匹配的方式获取这个结果。","title":"并发"},{"location":"/scala/scala.z.html","text":"","title":"小结"},{"location":"/scala/scala.z.html#小结","text":"本章简单的介绍了Scala的语言特性，本文并不只限于Java程序员，任何有编程经验的程序员都可以看。现在你应该对Scala有了一个基础的认识，并可以写一些 简单的代码了。在我的 博客 中分享了一些《Scala实战（系列）》文章，介绍更 函数式 的写法及与实际工程中结合的例子。 也欢迎对Scala感兴趣的同学与我联系，一起交流、学习。","title":"小结"},{"location":"/basic/index.html","text":"","title":"Akka HTTP 基础"},{"location":"/basic/index.html#akka-http-基础","text":"Akka HTTP 基础 Web 工作方式 使用 Akka Http 搭建一个简单的 Web 服务 第一个服务 Route JSON Route类型 Akka HTTP 的通用抽象 HTTP Model URI Model Marshalling Unmarshalling Encoding / Decoding JSON Support XML Support Akka HTTP Timeouts 小结","title":"Akka HTTP 基础"},{"location":"/basic/basic.0.html","text":"","title":"Akka HTTP 基础"},{"location":"/basic/basic.0.html#akka-http-基础","text":"Akka HTTP 是一个基于 akka-actor 和 akka-stream 的，实现了完整 HTTP 协议的包含 Server/Client 的工具包。它提供了提供和连接 HTTP 服务的通用工具集。它不是一个 Web 框架，因为它不关系于浏览器的交互及服务端页面渲染等（当然，你若需要也可以很方便的集成类似功能。或者直接使用 构建于 Akka HTTP 之上的 Playframework ）。\nAkka HTTP 是专门为 Not a framework 设计的，当你的核心不是与浏览器进行交互、服务端页面渲染……而是提供一些专门的或复杂的服务业务。通过 Rest/HTTP 接口来发布和连接到应用生态中，这时候一个 Web 框架可能显得比较笨重。这时，Akka HTTP 提供给你一个轻量、简洁、高效地……工具，你不再 需要关心 Javascript/CSS 发布、压缩等，只需要全力专注于服务（API）发布上。\n本章将带领读者进入 Akka HTTP 的世界，我们将介绍Akka Http的常用功能模块及使用方式，读完本章你就可以开始使用 Akka HTTP 构建自己的基于 HTTP 的微服务。Akka Http提供了一套强大、易用、易扩展的route dsl来构建路由。Akka Http Client因还不支持超时功能，现在不建议在产品中使用。\nAkka HTTP官方提供了如下模块：\nakka-http-xml：XML解析库，实现了 Marshalling/Unmarshalling akka-http-jackson：Jackson JSON解析库，实现了 Marshalling/Unmarshalling akka-http-spary-json：JSON库，实现了 Marshalling/Unmarshalling akka-http-testkit：测试工具 akka-http：高级API，包括 Marshall/Unmarshall、Directives等 akka-http-core：低级API，核心功能 akka-parsing：数据包解析等功能\n本章代码见：codes/akka-http-foundation","title":"Akka HTTP 基础"},{"location":"/basic/basic.1.html","text":"","title":"Web 工作方式"},{"location":"/basic/basic.1.html#web-工作方式","text":"这里，我们将主要讨论Web服务器的工作方式，Web 服务器会对 HTTP 请求进行处理并提供响应。实际的Web服务器主要会做以下这些任务：\n建立连接 接受一个客户端连接，或者如果不希望与这个客户端连接则将其关闭。 接收请求 从网络中读取一条 HTTP 请求报文。 处理请求 对请求报文进行解释，并采取行动。 访问资源 访问报文中指定的资源。 构建响应 创建带有正确首部的 HTTP 响应报文。 发送响应 将响应回头给客户端。 记录事务处理过程 将与已完成事务有关的内容记录在一个日志文件中。","title":"Web 工作方式"},{"location":"/basic/basic.2.html","text":"","title":"使用 Akka Http 搭建一个简单的 Web 服务"},{"location":"/basic/basic.2.html#使用-akka-http-搭建一个简单的-web-服务","text":"使用 Akka HTTP 需要对 akka-http 的依赖，请把如下配置写入你的 Sbt 工程配置文件中：\n\"com.typesafe.akka\" %% \"akka-http\" % \"10.1.5\"","title":"使用 Akka Http 搭建一个简单的 Web 服务"},{"location":"/basic/basic.2.html#第一个服务","text":"从官方提供的 HttpApp 特质开始，它提供了快捷的方式来启动一个Akka HTTP Server。\nclass WebServer extends HttpApp {\n  def route: Route =\n    path(\"hello\") {\n      get {\n        import akka.http.scaladsl.marshallers.xml.ScalaXmlSupport._\n        complete(<h1>Say hello to akka-http</h1>)\n      }\n    }\n}\npath(\"hello\")定义了一个HTTP访问路由，get代表这个路由提供了 GET 请示，而complete函数允许我们提供响应结果来完成这个路由定义，这里我们返回了一段文本。Akka Http的路由看起来向 声明式 的，以一直新颖而又直观的方式来定义HTTP服务。\n用户第一次接触这种函数套函数（又像树型结构）的代码方式可能不大习惯，其实我们可以换种方式来实现这段代码：\ndef traditionRoute: Route = {\n    val respResult = complete(\"result\") // 响应结果\n    val hPath = path(\"hello\") // 绑定的HTTP访问路径\n    hPath(get(result)) \n  }\n路径(Http方法(结果))，我们用Java式的风格来实现同样的功能。这样是不是更符合你对代码的预期？\n让我们来启动服务：\nobject Boot {\n  def main(args: Array[String]): Unit = {\n    val server = new WebServer\n    server.startServer(\"0.0.0.0\", 8888)\n  }\n}\n通过 curl 命令来测试下我们的第一个Akka HTTP服务（-i选项可以打印HTTP响应头）：\ncurl -i http://localhost:8888/hello\nHTTP/1.1 200 OK\nServer: akka-http/10.0.11\nDate: Sat, 24 Feb 2018 17:05:12 GMT\nContent-Type: text/html; charset=UTF-8\nContent-Length: 31\n\n<h1>Say hello to akka-http</h1>","title":"第一个服务"},{"location":"/basic/basic.2.html#route","text":"Akka HTTP 提供了一个灵活的 DSL ，它有很多可组合的元素（Directive 指令）以简洁、易读的方式来构建服务。让我们来看下面这个示例：\npath(\"book\") {\n    get {\n      parameters('name.as[Option[String]], 'isbn.as[Option[String]], 'author.as[Option[String]]) {\n        (maybeName, maybeIsbn, maybeAuthor) =>\n          complete(s\"name: $maybeName, isbn: $maybeIsbn, author: $maybeAuthor\")\n      }\n    }\n  }\n对于上面这个定义，类似的 Play 路由定义如：\nGET  /book controller.Page.book(name: Option[String], isbn: Option[String], author: Option[String)\n我们可以看到，对一个API路由的定义拆成了几个函数嵌套的形式。path指定访问路径，get决定这个API提供HTTP GET服务，parameters可以提取请求参数，而complete将一个字符串返回给前端。","title":"Route"},{"location":"/basic/basic.2.html#json","text":"现在大部分的服务都提供JSON格式的数据，Akka HTTP提供了 Mashaller/Unmashaller机制，用户可以基于此灵活的定制自己的序列化/反序列化方式。这里我们使用 Jackson 来解析/处理 JSON。\n首选，我们实现自定义的 Mashaller/Unmashaller：\ntrait JacksonSupport {\n\n  private val jsonStringUnmarshaller =\n    Unmarshaller.byteStringUnmarshaller\n      .forContentTypes(MediaTypes.`application/json`)\n      .mapWithCharset {\n        case (ByteString.empty, _) => throw Unmarshaller.NoContentException\n        case (data, charset) => data.decodeString(charset.nioCharset.name)\n      }\n\n  // HTTP entity => `A`\n  implicit def unmarshaller[A](\n                                implicit ct: ClassTag[A],\n                                objectMapper: ObjectMapper = Jackson.defaultObjectMapper\n                              ): FromEntityUnmarshaller[A] =\n    jsonStringUnmarshaller.map(\n      data => objectMapper.readValue(data, ct.runtimeClass).asInstanceOf[A]\n    )\n\n  // `A` => HTTP entity\n  implicit def marshaller[A](\n                              implicit objectMapper: ObjectMapper = Jackson.defaultObjectMapper\n                            ): ToEntityMarshaller[A] = {\n    JacksonHelper.marshaller[A](objectMapper)\n  }\n\n}\n实现自定义的 Marshaller/Unmarshaller 后，我们就可以在 Akka HTTP 中提供 Json 支持了。\npackage akkahttp.foundation.route\n\nimport akka.http.scaladsl.server.Route\nimport akkahttp.foundation.data.domain.PageInput\nimport akkahttp.json.JacksonSupport._\nimport akkahttp.server.BaseRoute\n\nclass PageRoute extends BaseRoute {\n\n  def route: Route =\n    path(\"page\") {\n      post {\n        entity(as[PageInput]) { pageInput =>\n          complete(pageInput)\n        }\n      }\n    }\n\n}\nAkka HTTP使用了Scala的隐式转换特性来自定义数据序列化，这是一个非侵入式的设计，用户可以在每个模块选择自己的数据序列化方式。","title":"JSON"},{"location":"/basic/basic.2.html#route类型","text":"Route 是 Akka HTTP 路由 DSL 里的核心概念，用它构建的所有结构，不管是一条线还是很多条线组成，它们都会是这个类型的实例。\ntype Route = RequestContext => Future[RouteResult]","title":"Route类型"},{"location":"/basic/basic.2.html#组合路由","text":"Akka HTTP 提供3个基本的操作来让我们创建更复杂的路由链：\n路由转换：它代理一个“内部”的路由，并在这个过程中改变一些请求传入的属性，然后传出响应或两者。 路由过滤：只允许满足给定条件的请求被传递，并拒绝所有其它访问请求。 路由链：如果第一个请求被拒绝，将尝试第二个路由。使用 ~ 操作符连接多个路由定义。\nAkka HTTP 实现了很多默认的指令 akka.http.scaladsl.server.Directives._ ，你也可以很轻松地创建自己的指令。指令提供了强大和灵活的方式来构建 Akka HTTP。","title":"组合路由"},{"location":"/basic/basic.2.html#路由树","text":"当通过嵌套和操作符组合指令和自定义路径时，将构建一个路由结构并形成一颗树。当一个 HTTP 请求进来，它将从根进行这颗树，并以深度优先的方式流过所有分支，直到某个节点完成或全部被拒绝为止。\nval route =\n  a {\n    b {\n      c {\n        ... // route 1\n      } ~\n      d {\n        ... // route 2\n      } ~\n      ... // route 3\n    } ~\n    e {\n      ... // route 4\n    }\n  }\n这里由5个指令构建了一个路由树：\n当 a, b, c都通过，才到到达路由 1 当 a 和 b 通过，但 c 被拒绝且 d 通过，将到达路由 2 当 a 和 b 通过，但 c 和 d 被拒绝，路由 3 被到达\n若路由 3 前面的请求都被拒绝，则它将“捕获”所有请求。这个机制使复杂的过滤逻辑可以很容易的实现。把简单和最具体的放在顶端，一般和普通的放到最后。","title":"路由树"},{"location":"/basic/basic.3.html","text":"","title":"Akka HTTP 的通用抽象"},{"location":"/basic/basic.3.html#akka-http-的通用抽象","text":"HTTP 规范定义了大量概念和功能，它们是不特定于具体实现的。本节将介绍通用于 client/server　的 API。\nHTTP Model：包括常见的请求、响应、headers等结构，代码都在 akka-http-core 模块，它们是构建大多次 Akka HTTP API的基础。 URI Model：根据 RFC 3986 实现了 URI 解析规则。 Marshalling：将高级（对象）结构转换成某种低级表示形式的过程，其它流行的名称有： Serialization 和 Pickling 。 Unmarshalling：将低级表示形式转换成某种高级（对象）结构的过程，其它流行的名称有： Deserialization 和 Unpickling 。 Encoding / Decoding：HTTP spec定义了 Content-Encoding头，实现了 HTTP 消息的压缩、解压缩。如：gzip、deflate…… JSON Support：根据 marshalling 和 unmarshalling 实现的 JSON 解析，默认提供了 akka-http-spray-json 模块。也可很容易的定义自己的 JSON 解析。 XML Support：根据 marshalling 和 unmarshalling 实现的 Scala XML 解析，默认提供了 akka-http-xml 模块。也可很容易的定义自己的 XML 解析。 Akka HTTP Timeouts：内建多种超时机制来保护服务器免受恶意攻击和编程错误。用户代码中可使用配置选项或API来定制。","title":"Akka HTTP 的通用抽象"},{"location":"/basic/basic.3.html#http-model","text":"akka-http-core 提供了 HTTP 数据结构的核心，很多的地方（包括你自己的代码）都导入了这些数据结构。主要的类型有：\nHttpRequest 和 HttpResponse：主要的消息模型 headers：这个 package 包含了所有的预定义 HTTP header 和支持和类型 支持的类型，比如：Uri、HttpMethods、MediaTypes、StatusCodes等\n通常，一个实体模型表现为一个不可变类型（class 或 trait）。由 HTTP 规范定义的实体类型的预定义实例都放在同名类型名加个一个 s 的复数形式 object 里。\n比如：\n定义的 HttpMethod 在 HttpMethods object。 定义的 HttpCharset 在 HttpCharsets object。 定义的 HttpEncoding 在 HttpEncodings object。 定义的 HttpProtocol 在 HttpProtocols object。 定义的 MediaType 在 MediaTypes object。 定义的 StatusCode 在 StatusCodes object。","title":"HTTP Model"},{"location":"/basic/basic.3.html#uri-model","text":"当尝试解析 URI 字符串时，Akka HTTP 将在内部创建 URI 的实例。下面是常见的一些有效的 URI 实例：\nUri(\"ftp://ftp.is.co.za/rfc/rfc1808.txt\") shouldEqual\n  Uri.from(scheme = \"ftp\", host = \"ftp.is.co.za\", path = \"/rfc/rfc1808.txt\")\n\nUri(\"http://www.ietf.org/rfc/rfc2396.txt\") shouldEqual\n  Uri.from(scheme = \"http\", host = \"www.ietf.org\", path = \"/rfc/rfc2396.txt\")\n\nUri(\"ldap://[2001:db8::7]/c=GB?objectClass?one\") shouldEqual\n  Uri.from(scheme = \"ldap\", host = \"[2001:db8::7]\", path = \"/c=GB\", queryString = Some(\"objectClass?one\"))\n\nUri(\"mailto:John.Doe@example.com\") shouldEqual\n  Uri.from(scheme = \"mailto\", path = \"John.Doe@example.com\")\n\nUri(\"news:comp.infosystems.www.servers.unix\") shouldEqual\n  Uri.from(scheme = \"news\", path = \"comp.infosystems.www.servers.unix\")\n\nUri(\"tel:+1-816-555-1212\") shouldEqual\n  Uri.from(scheme = \"tel\", path = \"+1-816-555-1212\")\n\nUri(\"telnet://192.0.2.16:80/\") shouldEqual\n  Uri.from(scheme = \"telnet\", host = \"192.0.2.16\", port = 80, path = \"/\")\n\nUri(\"urn:oasis:names:specification:docbook:dtd:xml:4.1.2\") shouldEqual\n  Uri.from(scheme = \"urn\", path = \"oasis:names:specification:docbook:dtd:xml:4.1.2\")","title":"URI Model"},{"location":"/basic/basic.3.html#marshalling","text":"Marshalling 是将类型 A 的实例转换成类型 B 的实例，提供于 Marshaller[A, B]。Akka HTTP 预定义了很多转换的别名，可以简化日常开发：\ntype ToEntityMarshaller[T] = Marshaller[T, MessageEntity]\ntype ToByteStringMarshaller[T] = Marshaller[T, ByteString]\ntype ToHeadersAndEntityMarshaller[T] = Marshaller[T, (immutable.Seq[HttpHeader], MessageEntity)]\ntype ToResponseMarshaller[T] = Marshaller[T, HttpResponse]\ntype ToRequestMarshaller[T] = Marshaller[T, HttpRequest]\nMarshaller[A, B] 本质上类似于 A => Future[List[Marshalling[B]]] 这样一个函数，这个签名比较复杂，下面我们来解析下它。\nFuture：这个很明显，Marshaller 不需要同步的产生一个结果，我们可以异步的进行这个编码过程。 List：列表，说明对于给定类型 A ，不到一个 Marshaller 被作用于它。比如对于：ToEntityMarshaller[OrderConfirmation]，请求可 能使用 JSON 或 XML 格式，客户端可以添加 Accept 请求头来决定使用哪个 Marshaller。若客户端未指定，则在序列化时将使用第一个。 Marshalling[B]：这里没有直接返回类型 B 的实例，而是返回一个 Marshalling[B]。这使得在编码过程中查询 MediaType 和检查可 能的 HttpCharset 成为了可能，这样的条件都匹配后才会触发编码工作。在启用了这样的类型协商的方式之外，这种设计还允许将 marshalling 对目标实 例的构造延迟到真正需要的时刻。","title":"Marshalling"},{"location":"/basic/basic.3.html#预定义-marshallers","text":"Akka HTTP 已经包含大量预定义 marshallers：\nPredefinedToEntityMarshallers Array[Byte] ByteString Array[Char] String akka.http.scaladsl.model.FormData akka.http.scaladsl.model.MessageEntity T <: akka.http.scaladsl.model.Multipart PredefinedToResponseMarshallers T, 如果 ToEntityMarshaller[T] 可用 HttpResponse StatusCode (StatusCode, T)，如果 ToEntityMarshaller[T] 可用 (Int, T)，如果 ToEntityMarshaller[T] 可用 (StatusCode, immutable.Seq[HttpHeader], T)，如果 ToEntityMarshaller[T] 可用 (Int, immutable.Seq[HttpHeader], T)，如果 ToEntityMarshaller[T] 可用 PredefinedToRequestMarshallers HttpRequest Uri (HttpMethod, Uri, T)，如果 ToEntityMarshaller[T] 可用 (HttpMethod, Uri, immutable.Seq[HttpHeader], T)，如果 ToEntityMarshaller[T] 可用 GenericMarshallers Marshaller[Throwable, T] Marshaller[Option[A], B]，如果 Marshaller[A, B] 和 EmptyValue[B] 可用 Marshaller[Either[A1, A2], B]，如果 Marshaller[A1, B] 和 Marshaller[A2, B] 可用 Marshaller[Future[A], B]，如果 Marshaller[A, B] 可用 Marshaller[Try[A], B]，如果 Marshaller[A, B] 可用","title":"预定义 Marshallers"},{"location":"/basic/basic.3.html#隐式解析","text":"Akka HTTP 的 marshalling 基础设施使用基于 class 的方式，这意味着 Marshaller 从一个特定 A 类型转换到 B 类型实例是隐式可用的。\nAkka HTTP 预定义 Marshaller trait，它们的定义都在同名伴生对象中，这意味着代码中不需要显示导入即可用。同时，你也可以定义自己的版本来覆盖它。\nobject Marshaller\n  extends GenericMarshallers\n  with PredefinedToEntityMarshallers\n  with PredefinedToResponseMarshallers\n  with PredefinedToRequestMarshallers {\n  ...\n}","title":"隐式解析"},{"location":"/basic/basic.3.html#使用-marshallers","text":"可以在代码中直接使用 Marshallers，akka.http.scaladsl.marshalling.Marshal object 是一个很好的入口：\nimport scala.concurrent.Await\nimport scala.concurrent.duration._\nimport akka.http.scaladsl.marshalling.Marshal\nimport akka.http.scaladsl.model._\n\nimport system.dispatcher // ExecutionContext\n\nval string = \"Yeah\"\nval entityFuture = Marshal(string).to[MessageEntity]\nval entity = Await.result(entityFuture, 1.second) // 非测试代码中不要这么使用！\nentity.contentType shouldEqual ContentTypes.`text/plain(UTF-8)`\n\nval errorMsg = \"Easy, pal!\"\nval responseFuture = Marshal(420 -> errorMsg).to[HttpResponse]\nval response = Await.result(responseFuture, 1.second) // 非测试代码中不要这么使用！\nresponse.status shouldEqual StatusCodes.EnhanceYourCalm\nresponse.entity.contentType shouldEqual ContentTypes.`text/plain(UTF-8)`\n\nval request = HttpRequest(headers = List(headers.Accept(MediaTypes.`application/json`)))\nval responseText = \"Plaintext\"\nval respFuture = Marshal(responseText).toResponseFor(request) // 根据请求来决定使用哪个 Marshaller\na[Marshal.UnacceptableResponseContentTypeException] should be thrownBy {\n  Await.result(respFuture, 1.second) // 客户端请求 JSON 格式，但这里只提供了 `text/plain` 的编码方式\n}","title":"使用 Marshallers"},{"location":"/basic/basic.3.html#unmarshalling","text":"Unmarshalling 将类型 A 的实例转换成类型 B，Unmarshaller[A, B]。Akka HTTP 预定义了很多转换的别名，可以简化日常开发：\ntype FromEntityUnmarshaller[T] = Unmarshaller[HttpEntity, T]\ntype FromMessageUnmarshaller[T] = Unmarshaller[HttpMessage, T]\ntype FromResponseUnmarshaller[T] = Unmarshaller[HttpResponse, T]\ntype FromRequestUnmarshaller[T] = Unmarshaller[HttpRequest, T]\ntype FromByteStringUnmarshaller[T] = Unmarshaller[ByteString, T]\ntype FromStringUnmarshaller[T] = Unmarshaller[String, T]\ntype FromStrictFormFieldUnmarshaller[T] = Unmarshaller[StrictForm.Field, T]\n核心的 Unmarshaller[A, B] 类型非常类似 A => Future[B] 函数，它提供了一个解码的转换流程。","title":"Unmarshalling"},{"location":"/basic/basic.3.html#预定义-unmarshallers","text":"Akka HTTP 已经预定义了大量的 marshallers，我们可以在代码中直接使用：\nPredefinedFromStringUnmarshallers Byte Short Int Long Float Double Boolean PredefinedFromEntityUnmarshallers Array[Byte] ByteString Array[Char] String akka.http.scaladsl.model.FormData GenericUnmarshallers Unmarshaller[T, T] (identity unmarshaller) Unmarshaller[Option[A], B]，如果 Unmarshaller[A, B] 可用 Unmarshaller[A, Option[B]], 如果 Unmarshaller[A, B] 可用","title":"预定义 Unmarshallers"},{"location":"/basic/basic.3.html#隐式解析","text":"Akka HTTP 的 unmarshalling 基础设施使用基于 class 的方式，这意味着 Unmarshaller 从一个特定 A 类型转换到 B 类型实例是隐式可用的。\nAkka HTTP 预定义 Unmarshaller trait，它们的定义都在同名伴生对象中，这意味着代码中不需要显示导入即可用。同时，你也可以定义自己的版本来覆 盖它。\nobject Unmarshaller\n  extends GenericUnmarshallers\n  with PredefinedFromEntityUnmarshallers\n  with PredefinedFromStringUnmarshallers {\n  ....\n}","title":"隐式解析"},{"location":"/basic/basic.3.html#使用-unmarshallers","text":"在 Akka HTTP 中有许多地方隐式的使用了 Unmarshallers ，比对 Routing DSL 里面的 entity(as[T])。但是，也可以显示的使用它，一个很好的切 入点是：akka.http.scaladsl.unmarshalling.Unmarshal object，可以如下使用：\nimport akka.http.scaladsl.unmarshalling.Unmarshal\nimport system.dispatcher // Optional ExecutionContext (default from Materializer)\nimplicit val materializer: Materializer = Materializer(system)\n\nimport scala.concurrent.Await\nimport scala.concurrent.duration._\n\nval intFuture = Unmarshal(\"42\").to[Int]\nval int = Await.result(intFuture, 1.second) // don't block in non-test code!\nint shouldEqual 42\n\nval boolFuture = Unmarshal(\"off\").to[Boolean]\nval bool = Await.result(boolFuture, 1.second) // don't block in non-test code!\nbool shouldBe false","title":"使用 Unmarshallers"},{"location":"/basic/basic.3.html#encoding-decoding","text":"当前 Akka HTTP 支持 gzip 和 deflate 格式的压缩、解压缩，它们的代码逻辑都在 akka.http.scaladsl.coding 包中。","title":"Encoding / Decoding"},{"location":"/basic/basic.3.html#json-support","text":"Akka HTTP 包含了一个 akka-http-spary-json 模块，它实现了完整的 JSON 支持。","title":"JSON Support"},{"location":"/basic/basic.3.html#jacksonsupport","text":"详细见： JSON","title":"JacksonSupport"},{"location":"/basic/basic.3.html#xml-support","text":"","title":"XML Support"},{"location":"/basic/basic.3.html#scala-xml支持","text":"Scala语言内建了 XML 支持。 ScalaXmlSupport trait　 提供了 FromEntityUnmarshaller[NodeSeq] 和 ToEntityMarshaller[NodeSeq]，可以在代码中直接使用。\n添加库依赖：\"com.typesafe.akka\" %% \"akka-http-xml\" % \"1.x\" 引入隐式转换 import akka.http.scaladsl.marshallers.xml.ScalaXmlSupport._，或混入 akka.http.scaladsl.marshallers.xml.ScalaXmlSupport trait。","title":"Scala XML支持"},{"location":"/basic/basic.3.html#akka-http-timeouts","text":"","title":"Akka HTTP Timeouts"},{"location":"/basic/basic.3.html#通用超时","text":"idle-timeout （空闲超时）是一个全局配置项，设置给定连接的最大非活动时间。若一个连接是打开的，但在给定时间内没有请求/响应数据写入，则连接将 被自动关闭。它们有如下配置项：\nakka.http.server.idle-timeout akka.http.client.idle-timeout akka.http.host-connection-pool.idle-timeout akka.http.host-connection-pool.client.idle-timeout","title":"通用超时"},{"location":"/basic/basic.3.html#服务端超时","text":"","title":"服务端超时"},{"location":"/basic/basic.3.html#请求超时","text":"请求超时设置服务端产生一个 HttpResponse 响应的最大超时时间，若超时到，则服务端将自动注入一个 Unavailable HTTP 响应并关闭连接。默认 的超时时间是 20秒，可通过 akka.http.server.request-timeout 进行配置。","title":"请求超时"},{"location":"/basic/basic.3.html#bind-timeout-绑定超时-","text":"在给定时间内，使用 TCP 协议绑定 address/port 的进程必需完成（任何 Http().bind* 方法），可以使用 akka.http.server.bind-timeout 设置。","title":"Bind timeout（绑定超时）"},{"location":"/basic/basic.3.html#linger超时","text":"Linger（逗留）超时是指服务端的所有数据被传递到网络层后还保持连接打开的时间。这个设置类似 SO_LINGER 套接字（Socket）选项，但这里还包括了 Akka IO 和 Akka Streams 网络栈。这是一个额外的预防措施，防止客户端长时间保持打开服务端已被认为完成了的连接。","title":"Linger超时"},{"location":"/basic/basic.3.html#客户端超时","text":"","title":"客户端超时"},{"location":"/basic/basic.3.html#连接超时","text":"连接超时是客户端通过 TCP 协议连接上服务端必须完成的时间，通常不需要修改它。但可以使用 akka.http.client.connecting-timeout 进行自定义。","title":"连接超时"},{"location":"/basic/basic.z.html","text":"","title":"小结"},{"location":"/basic/basic.z.html#小结","text":"本章我们创建了我们的第一个 Akka HTTP 程序，并快速了过了下 Akka HTTP 所提供的功能。","title":"小结"},{"location":"/server-api/index.html","text":"","title":"服务端API"},{"location":"/server-api/index.html#服务端api","text":"Akka HTTP 如何使得 Web 工作 启动和停止 请求、响应生命周期 错误处理 绑定失败 (Bind failures) 连接源失败 (Connection Source failures) 连接失败 (Connection failures) 高级服务端 API","title":"服务端API"},{"location":"/server-api/work.html","text":"","title":"Akka HTTP 如何使得 Web 工作"},{"location":"/server-api/work.html#akka-http-如何使得-web-工作","text":"Akka HTTP 有 Low-Level 和 High-Level 两套服务端 API，这里我们来看看 Low-Level API，这会使你对 Akka HTTP 是怎样运行会 有一个深入的认识。\nAkka HTTP 提供了一个基于 Reactive-Streams (反映式流)，全异步的 HTTP/1.1 服务端实现，支持以下特性：\n完整支持 HTTP 持久化连接 完整支持 HTTP 流水线 完整支持异步 HTTP 流，包括 “chunked” （分块的）编码 SSL/TLS 加密支持 WebSocket 支持\nAkka HTTP 服务端组件有两层：\nakka-http-core：基本的低级API实现，提供了更偏底层的 HTTP 功能 akka-http：高级API实现，提供了易用的DSL（Directives）\nlow-level 聚焦于提供实现完整 HTTP/1.1 协议的基本功能：\n连接管理 解析和渲染“消息”及 headers 超时管理（请求连接和服务端 accept 连接） 响应顺序（透明的流水线 (pipeline) 支持）\n所有的非核心功能都放到了 akka-http 模块，如：路由、文件处理、压缩等等）。","title":"Akka HTTP 如何使得 Web 工作"},{"location":"/server-api/work.html#启动和停止","text":"Akka HTTP 提供了 bind 这个方法来启动服务，它通过指定 interface 和 port 来绑定服务，并注册处理函数来处理进入的 HTTP 连接。\nimport akka.actor.ActorSystem\nimport akka.http.scaladsl.Http\nimport akka.stream.Materializer\nimport akka.stream.scaladsl._\n\nimplicit val system = ActorSystem()\nimplicit val materializer = Materializer(system)\nimplicit val executionContext = system.dispatcher\n\nval serverSource: Source[Http.IncomingConnection, Future[Http.ServerBinding]] =\n  Http().bind(interface = \"localhost\", port = 8080)\nval bindingFuture: Future[Http.ServerBinding] =\n  serverSource.to(Sink.foreach { connection => // foreach materializes the source\n    println(\"Accepted new connection from \" + connection.remoteAddress)\n    // ... and then actually handle the connection\n  }).run()\nHttp.ServerBinding 实例有一个 unbind() 方法，通过它可以停止 Akka HTTP 服务。","title":"启动和停止"},{"location":"/server-api/work.html#请求-响应生命周期","text":"低级别的 Akka HTTP 服务端 API 在 akka-http-core 模块提供了 HttpRequest 来接受多个或单个连接，并由 HttpResponse 生成响应。处理这 些请求/响应的函数调用类型叫做：Flow[HttpRequest, HttpResponse, _] ，由它来“转换” 请求（HttpRequest） 到 响应（HttpResponse） 。\n收到的 HTTP 请求通过调用 handleWithXXX 中的一个来处理，主要的方法有：\nFlow[HttpRequest, HttpResponse, _] 由 handleWith 方法使用 HttpRequest => HttpResponse 函数由 handleWithSyncHandler 方法使用 HttpRequest => Future[HttpResponse] 函数由 handleWithAsyncHandler 方法使用\n一个 HttpRequest => HttpResponse 函数的例子如下：\nval requestHandler: HttpRequest => HttpResponse = {\n  case HttpRequest(GET, Uri.Path(\"/\"), _, _, _) =>\n    HttpResponse(entity = HttpEntity(\n      ContentTypes.`text/html(UTF-8)`,\n      \"<html><body>Hello world!</body></html>\"))\n\n  case HttpRequest(GET, Uri.Path(\"/ping\"), _, _, _) =>\n    HttpResponse(entity = \"PONG!\")\n\n  case HttpRequest(GET, Uri.Path(\"/crash\"), _, _, _) =>\n    sys.error(\"BOOM!\")\n\n  case r: HttpRequest =>\n    r.discardEntityBytes() // important to drain incoming HTTP Entity stream\n    HttpResponse(404, entity = \"Unknown resource!\")\n}\n\nval bindingFuture: Future[Http.ServerBinding] =\n  serverSource.to(Sink.foreach { connection =>\n    println(\"Accepted new connection from \" + connection.remoteAddress)\n\n    connection handleWithSyncHandler requestHandler\n    // this is equivalent to\n    // connection handleWith { Flow[HttpRequest] map requestHandler }\n  }).run()\n在这个例子里，一个请求被 HttpRequest => HttpResponse 函数处理，使用 handleWithSyncHandler 来绑定了这一系列转换操作（等价于 Akka Stream 的 map 操作）。","title":"请求、响应生命周期"},{"location":"/server-api/work.html#错误处理","text":"在 Akka HTTP 服务初始化和运行中可能有各种各样的故障或错误情况发生。Akka 默认记录下了所有这些错误，但有时候需要自行处理这些错误，如：记录错误 发生的情况，关闭 Actor系统，或通知一些外部的监控端点……\n有很多情况会造成在创建和实现一个服务时错误，有各种类型的错误，常见的包括：\nbind 到指定 address/port 失败。 接受新的 IncommingConnection 时失败，如操作系统可打开文件描述符已用完或内存不足。 处理一个连接时错误，如传入的请求数据无效。\n下面介绍下常见的故障情况及怎样处理这些故障。","title":"错误处理"},{"location":"/server-api/work.html#绑定失败-bind-failures-","text":"val serverSource = Http().bind(\"localhost\", 80)\n\nval bindingFuture: Future[ServerBinding] = serverSource\n  .to(handleConnections) // Sink[Http.IncomingConnection, _]\n  .run()\n\nbindingFuture.failed.foreach { ex =>\n  log.error(ex, \"Failed to bind to {}:{}!\", \"localhost\", 80)\n}\n当 bind 到 80 端口时，很有可能程序没有权限（需要 root 权限才能绑定到 80 端口），或者端口已被其它程序占用……这时就会发生**绑定故障**。上 面例子里，bindingFuture 将立即失败，我们可以监听 onFaliure 函数对指定的异常做出处理。","title":"绑定失败 (Bind failures)"},{"location":"/server-api/work.html#连接源失败-connection-source-failures-","text":"下面的例子，我们通过一个 failureMonitor actor来捕获 IncomingConnection 错误，由 Actor 来处理这个错误，也许它会决定重启服务或关闭整个 ActorSystem　。\nval failureMonitor: ActorRef = system.actorOf(MyExampleMonitoringActor.props)\n\nval reactToTopLevelFailures = Flow[IncomingConnection]\n  .watchTermination()((_, termination) => termination.failed.foreach { cause =>\n    failureMonitor ! cause\n  })\n\nserverSource\n  .via(reactToTopLevelFailures)\n  .to(handleConnections) // Sink[Http.IncomingConnection, _]\n  .run()","title":"连接源失败 (Connection Source failures)"},{"location":"/server-api/work.html#连接失败-connection-failures-","text":"故障发生的第3种情况是连接已经建立，但在响应前突然终止，如：client中止了底层的TCP连接。这里此类故障可以使用与前一个相似的处理方式，但是我们将这个应用这个连接的处理流程中。\nval reactToConnectionFailure = Flow[HttpRequest]\n  .recover[HttpRequest] {\n    case ex =>\n      // handle the failure somehow\n      throw ex\n  }\n\nval httpEcho = Flow[HttpRequest]\n  .via(reactToConnectionFailure)\n  .map { request =>\n    // simple streaming (!) \"echo\" response:\n    HttpResponse(entity = HttpEntity(ContentTypes.`text/plain(UTF-8)`, request.entity.dataBytes))\n  }\n\nserverSource\n  .runForeach { con =>\n    con.handleWith(httpEcho)\n  }\n大部分时间你都不需要深入理解这个故障处理，Akka 详细的记录了这些故障日志，并有一系列默认的方式来处理这些故障。","title":"连接失败 (Connection failures)"},{"location":"/server-api/advanced.html","text":"","title":"高级服务端 API"},{"location":"/server-api/advanced.html#高级服务端-api","text":"除了低级服务端 API，Akka HTTP 还提供了非常灵活的 Routing DSL 来优雅的定义 RESTful 风格的 Web 服务。\nAkka HTTP 高级 API 提供了如下功能特性：\n基于高级 API 的 HTTP Server 错误处理 服务端 HTTPS 支持 Routing DSL：将各种元素（Directives 指令）进行组合，以简洁、易读的方式使用 DSL 来表达服务 Routes：“路由”是 Akka HTTP 提供的 Routing DSL 的核心概念，使用 DSL 构建的所有结构，不管是单条还是很多，都是如下类型的实例：type Route = RequestContext => Future[RouteResult] Directives：“指令”是用来创建复杂路由结构的小积木。Akka HTTP 已经预定义了大量的 directives，你也可以很方便的建立自己的指令。 Rejections：在多个路由的构建中，~ 操作符允许第1条路由被拒绝后继续第2条路由，直到被处理为止。这是，若没有任何路由被匹配，则 “rejections” 可以提供友好的错误处理。 Exception 处理：当路由中有异常被抛出时，使用 ExceptionHandler 可以优雅的进行错误处理或恢复。 Case Class 提取：可以将请求参数提取成一个 case class，如：parameters('red.as[Int], 'green.as[Int], 'blue.as[Int]).as(Color) { color => Source Streaming：与 Akka Stream 的结合 Route TestKit：方便对路由和各 Akka HTTP 功能进行测试","title":"高级服务端 API"},{"location":"/routing-dsl/index.html","text":"","title":"路由DSL"},{"location":"/routing-dsl/index.html#路由dsl","text":"Akka HTTP提供了高级的抽象来定义服务端路由：Route，以简洁和可读的方式将服务行为表示为可组合的元素（称为 Directive (指令)）。指令被组装成起来形成所谓的路由结构，该路由结构的最顶层可用于创建提供给Http.handleFlow处理的流（Flow[HttpRequest, HttpResponse, NotUsed]，由Route.handleFlow显示调用生成，也可由RouteResult.route2HandlerFlow来隐式转换）。\n之前在 [使用 Akka Http 搭建一个简单的 Web 服务] 已经见过了一个例子。本章将深入的讲解 Routing DSL，看完本章后你当可在业务代码中灵活的运用 Routing DSL 。\nRoute 是Akka HTTP提供的 Routing DSL 的核心概念。使用 DSL 构建的所有路由结构（无论单个还是多个），最终都会将类型RequestContext转换为Future[RouteResult]。\nRoute 路由 RequestContext RouteResult 组合路由 路由树 Directive 指令 指令基础 指令可以做什么？ 组合指令 使用concat来连接多个指令 类型安全的指令 指令类型参数里的 Tuple （自动拉平 flattening） 自定义指令 命名配置 转换已存在的指令 从头开始实现一个指令 拒绝 rejections 异常处理 实战：大文件断点上传、下载和秒传 断点下载 断点上传 秒传 运行示例 小结","title":"路由DSL"},{"location":"/routing-dsl/route.html","text":"","title":"Route 路由"},{"location":"/routing-dsl/route.html#route-路由","text":"type Route = RequestContext => Future[RouteResult]\nAkka HTTP 里路由是类型 Route 只是一个类型别名，它实际上是一个函数 RequestContext => Future[RouteResult]，它接受一个 RequestContext 参数，并返回 Future[RouteResult]。RequestContext保存了每次HTTP请求的上下文，包括HttpRequest、unmatchedPath、settings等请求资源，还有4个函数来响应数据给客户端：\ndef complete(obj: ToResponseMarshallable): Future[RouteResult]：请求正常完成时调用，返回数据给前端。通过 Marshal 的方式将用户响应的数据类型转换成 HttpResponse，再赋值给RouteResult.Complete。 def reject(rejections: Rejection*): Future[RouteResult]：请求不能被处理时调用，如：路径不存、HTTP方法不支持、参数不对、Content-Type不匹配等。也可以自定义Rejection类型。 def redirect(uri: Uri, redirectionType: Redirection): Future[RouteResult]：用指定的url地址和给定的HTTP重定向响应状态告知客户端需要重定向的地址和方式。redirect实际上是对complete的封装，可以通过向complete函数传入指定的HttpResponse实例实现： complete(HttpResponse(\n  status = redirectionType,\n  headers = headers.Location(uri) :: Nil,\n  entity = redirectionType.htmlTemplate match {\n    case \"\"       => HttpEntity.Empty\n    case template => HttpEntity(ContentTypes.`text/html(UTF-8)`, template format uri)\n  }))\n def fail(error: Throwable): Future[RouteResult]：将给定异常实例气泡方式向上传递，将由最近的handleExceptions指令和ExceptionHandler句柄处理该异常（若异常类型是RejectionError，将会被包装成Rejection来执行）。","title":"Route 路由"},{"location":"/routing-dsl/route.html#requestcontext","text":"RequestContext包装了HTTP请求的实例HttpRequest和运行时需要的一些上下文信息，如：ExcutionContext、Materializer、LoggingAdapter、RoutingSettings等，还有unmatchedPath，该值描述了请求UIR还未被匹配的路径。\nunmatchedPath 若请求URI地址为：/api/user/page，对于如下路由定义unmatchedPath将为 /user/page。   pathPrefix(\"api\") { ctx =>\n    // ctx.unmatchedPath 等价于 \"/user/page\"\n    ctx.complete(ctx.request.uri.path.toString())\n  }","title":"RequestContext"},{"location":"/routing-dsl/route.html#routeresult","text":"RouteResult是一个简单的ADT（抽象数据类型），对路由执行后可能的结果进行建模，定义为：\nsealed trait RouteResult extends javadsl.server.RouteResult\n\nobject RouteResult {\n  final case class Complete(response: HttpResponse) extends javadsl.server.Complete with RouteResult {\n    override def getResponse = response\n  }\n  final case class Rejected(rejections: immutable.Seq[Rejection]) extends javadsl.server.Rejected with RouteResult {\n    override def getRejections = rejections.map(r => r: javadsl.server.Rejection).toIterable.asJava\n  }\n}\n通常不需要我们直接创建RouteResult实例，而是通过预定义的指令RouteDirectives定义的函数（complete、reject、redirect、fail）或RequestContext上的方法来创建。","title":"RouteResult"},{"location":"/routing-dsl/route.html#组合路由","text":"将单个的路由组合成一个复杂的路由结构一般有3种方法：\n路由转换（嵌套），将请求委托给另一个“内部”路由，在此过程中可以更改传请求和输出结果的某些属性。 过滤路由，只允许满足给定条件的路由通过。 链接路由，若给定的第一个路由被拒绝（reject），将尝试第二个路由，并依次类推。通过级联操作符~来实现，导入akka.http.scaladsl.server.Directvies._后可用。\n前两种方法可由指令（Directive）提供，Akka HTTP已经预告定义了大量开箱即用的指令，也可以自定义我们自己的指令。通过指令这样的机制，使得Akka HTTP的路由定义异常强大和灵活。","title":"组合路由"},{"location":"/routing-dsl/route.html#路由树","text":"当通过嵌套和链接将指令和自定义路由组合起来构建成一个路由结构时，将形成一颗树。当一个HTTP请求进入时，它首先被注入的树的根，并以深入优先的方式向下流径所有分支，直到某个节点完成它（返回Future[RouteResult.Complete]）或者完全拒绝它（返回Future[RouteResult.Rejected]）。这种机制可以使复杂的路由匹配逻辑可以非常容易的实现：简单地将最特定的情况放在前面，而将一般的情况放在后面。\nval route =\n  a {\n    b {\n      c {\n        ... // route 1\n      } ~\n      d {\n        ... // route 2\n      } ~\n      ... // route 3\n    } ~\n    e {\n      ... // route 4\n    }\n  }\n上面这个例子：\nroute 1 只有当a、b、c都通过时才会到达。 route 2 只有当a、b通过，但c被拒绝时才会到达。 route 3 只有当a、b通过，但c、d和它之前的所有链接的路由都被拒绝时才会到达。 可以被看作一个捕获所有（catch-all）的默认路由，之后会看到我们将利用此特性来实现服务端对SPA前端应用的支持。 route 4 只有当a通过，b和其所有子节点都被拒绝时才会到达。","title":"路由树"},{"location":"/routing-dsl/directive.html","text":"","title":"Directive 指令"},{"location":"/routing-dsl/directive.html#directive-指令","text":"指令 是用于创建任意复杂路由结构的小型构建块，Akka HTTP已经预先定义了大部分指令，当然我们也可以很轻松的定义自己的指令。","title":"Directive 指令"},{"location":"/routing-dsl/directive.html#指令基础","text":"通过指令来创建路由，需要理解指令是如何工作的。我们先来看看指令和原始的Route的对比。因为Route只是函数的类型别名，所有Route实例可以任何方式写入函数实例，如作为函数文本：\nval route: Route = { ctx => ctx.complete(\"yeah\") }  // 或者可简写为：_.complete(\"yeah\")\n而complete指令将变得更短：\nval route: Route = complete(\"yeah\")\ncomplete指令定义如下：\ndef complete(m: => ToResponseMarshallable): StandardRoute =\n  StandardRoute(_.complete(m))\n\nabstract class StandardRoute extends Route {\n  def toDirective[L: Tuple]: Directive[L] = StandardRoute.toDirective(this)\n}\n\nobject StandardRoute {\n  def apply(route: Route): StandardRoute = route match {\n    case x: StandardRoute => x\n    case x                => new StandardRoute { def apply(ctx: RequestContext) = x(ctx) }\n  }\n}","title":"指令基础"},{"location":"/routing-dsl/directive.html#指令可以做什么-","text":"指令用来灵活、高效的构造路由结构，简单来说它可以做如下这些事情：\n将Route传入的请求上下文RequestContext转换为内部路由需要的格式（修改请求）。 mapRequest(request => request.withHeaders(request.headers :+ RawHeader(\"custom-key\", \"custom-value\")))\n 根据设置的逻辑来过滤RequestContext，符合的通过（pass），不符合的拒绝（reject）。 path(\"api\" / \"user\" / \"page\")\n 从RequestContext中提取值，并使它在内部路径内的路由可用。 extract(ctx => ctx.request.uri)\n 定义一些处理逻辑附加到Future[RouteRoute]的转换链上，可用于修改响应或拒绝。 mapRouteResultPF {\n  case RouteResult.Rejected(_) =>\n    RouteResult.Complete(HttpResponse(StatusCodes.InternalServerError))\n}\n 完成请求（使用complete） complete(\"OK\")\n指令已经包含了路由（Route）可以用的所有功能，可以对请求和响应进行任意复杂的转换处理。","title":"指令可以做什么？"},{"location":"/routing-dsl/directive.html#组合指令","text":"Akka HTTP提供的Routing DSL构造出来的路由结构是一颗树，所以编写指令时通常也是通过“嵌套”的方式来组装到一起的。看一个简单的例子：\nval route: Route =\n  pathPrefix(\"user\") {\n    pathEndOrSingleSlash { // POST /user\n      post {\n        entity(as[User]) { payload =>\n          complete(payload)\n        }\n      }\n    } ~\n    pathPrefix(IntNumber) { userId =>\n      get { // GET /user/{userId}\n        complete(User(Some(userId), \"\", 0))\n      } ~\n      put { // PUT /user/{userId}\n        entity(as[User]) { payload =>\n          complete(payload)\n        }\n      } ~\n      delete { // DELETE /user/{userId}\n        complete(\"Deleted\")\n      }\n    }\n  }\nAkka HTTP提供的Routing DSL以树型结构的方式来构造路由结构，它与 Playframework 和 Spring 定义路由的方式不太一样，很难说哪一种更好。也许刚开始时你会不大习惯这种路由组织方式，一但熟悉以后你会认为它非常的有趣和高效，且很灵活。\n可以看到，若我们的路由非常复杂，它由很多个指令组成，这时假若还把所有路由定义都放到一个代码块里实现就显得非常的臃肿。因为每一个指令都是一个独立的代码块，它通过函数调用的形式组装到一起，我们可以这样对上面定义的路由进行拆分。\nval route1: Route =\n  pathPrefix(\"user\") {\n    pathEndOrSingleSlash {\n      post {\n        entity(as[User]) { payload =>\n          complete(payload)\n        }\n      }\n    } ~\n    pathPrefix(IntNumber) { userId =>\n      innerUser(userId)\n    }\n  }\n\ndef innerUser(userId: Int): Route =\n  get {\n    complete(User(Some(userId), \"\", 0))\n  } ~\n  put {\n    entity(as[User]) { payload =>\n      complete(payload)\n    }\n  } ~\n  delete {\n    complete(\"Deleted\")\n  }\n通过&操作符将多个指令组合成一个，所有指令都符合时通过。\nval pathEndPost: Directive[Unit] = pathEndOrSingleSlash & post\n\nval createUser: Route = pathEndPost {\n  entity(as[User]) { payload =>\n    complete(payload)\n  }\n}\n通过|操作符将多个指令组合成一个，只要其中一个指令符合则通过。\nval deleteEnhance: Directive1[Int] =\n  (pathPrefix(IntNumber) & delete) | (path(IntNumber / \"_delete\") & put)\n\nval deleteUser: Route = deleteEnhance { userId =>\n  complete(s\"Deleted User, userId: $userId\")\n}\nNote 上面这段代码来自真实的业务，因为某些落后于时代的安全原因，网管将HTTP的PUT、DELETE、HEAD等方法都禁用了，只保留了GET、POST两个方法。使用如上的技巧可以同时支持两种方式来访问路由。 还有一种方案来解决这个问题 val deleteUser2 = pathPrefix(IntNumber) { userId =>\n  overrideMethodWithParameter(\"httpMethod\") {\n    delete {\n      complete(s\"Deleted User, userId: $userId\")\n    }\n  }\n} 客户端不需要修改访问地址为 /user/{userId}/_delete，它只需要这样访问路由 POST /user/{userId}?httpMethod=DELETE。overrideMethodWithParameter(\"httpMethod\")会根据httpMethod参数的值来将请求上下文里的HttpRequest.method转换成 DELETE 方法请求。\nWarning 可以看到，将多个指令组合成一个指令可以简化我们的代码。但是，若过多地将几个指令压缩组合成一个指令，可能并不会得到易读、可维护的代码。","title":"组合指令"},{"location":"/routing-dsl/directive.html#使用concat来连接多个指令","text":"除了通过~链接操作符来将各个指令连接起来形成路由树，也可以通过concat指令来将同级路由（指令）连接起来（子路由还是需要通过嵌套的方式组合）。\nval route: Route = concat(a, b, c) // 等价于 a ~ b ~ c","title":"使用concat来连接多个指令"},{"location":"/routing-dsl/directive.html#类型安全的指令","text":"当使用&和|操作符组合多个指令时，Routing DSL将确保其按期望的方式工作，并且还会在编译器检查是否满足逻辑约束。下面是一些例子：\nval route1 = path(\"user\" / IntNumber) | get // 不能编译\nval route2 = path(\"user\" / IntNumber) | path(\"user\" / DoubleNumber) // 不能编译\nval route3 = path(\"user\" / IntNumber) | parameter('userId.as[Int]) // OK\n\n// 组合指令同时从URI的path路径和查询参数时获取值\nval pathAndQuery = path(\"user\" / IntNumber) & parameters('status.as[Int], 'type.as[Int])\nval route4 = pathAndQuery { (userId, status, type) =>\n    ....\n  }","title":"类型安全的指令"},{"location":"/routing-dsl/directive.html#指令类型参数里的-tuple-自动拉平-flattening-","text":"abstract class Directive[L](implicit val ev: Tuple[L])\n\ntype Directive0 = Directive[Unit]\ntype Directive1[T] = Directive[Tuple1[T]]\n指令的定义，它是一个泛型类。参数类型L需要可转化成akka.http.scaladsl.server.util.Tuple类型（即Scala的无组类型，TupleX）。下面是一些例子，DSL可以自动转换参数类型为符合的Tuple。\nval futureOfInt: Future[Int] = Future.successful(1)\nval route =\n  path(\"success\") {\n    onSuccess(futureOfInt) { //: Directive[Tuple1[Int]]\n      i => complete(\"Future was completed.\")\n    }\n  }\nonSuccess(futureOfInt)将返回值自动转换成了Directive[Tuple1[Int]]，等价于Directive1[Int]。\nval futureOfTuple2: Future[Tuple2[Int,Int]] = Future.successful( (1,2) )\nval route =\n  path(\"success\") {\n    onSuccess(futureOfTuple2) { //: Directive[Tuple2[Int,Int]]\n      (i, j) => complete(\"Future was completed.\")\n    }\n  }\nonSuccess(futureOfTuple2)返回Directive1[Tuple2[Int, Int]]，等价于Directive[Tuple1[Tuple2[Int, Int]]]。但DSL将自动转换成指令Directive[Tuple2[Int, Int]]以避免嵌套元组。\nval futureOfUnit: Future[Unit] = Future.successful( () )\nval route =\n  path(\"success\") {\n    onSuccess(futureOfUnit) { //: Directive0\n      complete(\"Future was completed.\")\n    }\n  }\n对于Unit，它比较特殊。onSuccess(futureOfUnit)返回Directive[Tuple1[Unit]]。DSL将会自动转换为Directive[Unit]，等价于Directive0。","title":"指令类型参数里的 Tuple （自动拉平 flattening）"},{"location":"/routing-dsl/custom-directive.html","text":"","title":"自定义指令"},{"location":"/routing-dsl/custom-directive.html#自定义指令","text":"有3种创建自定义指令的基本方法：\n将已有指令通过命名配置（比如通过组合的方式）的方式来定义新的指令 转换已存在的指令 从头开始实现一个指令","title":"自定义指令"},{"location":"/routing-dsl/custom-directive.html#命名配置","text":"创建自定义指令最简便的方法就是将一个或多个已有指令通过配置的方式分配一个新的名字来定义。事实上Akka HTTP预定义的大多数指令都由以较低级别指令命名配置的方式来定义的。如：\nval getPut = get & put\n\ndef postEntity[T](um: FromRequestUnmarshaller[T]): Directive1[T] = post & entity(um)\n\ndef completeOk: Route = complete(HttpEntity.Empty)\n\ndef completeNotImplemented: Route = complete(StatusCodes.NotImplemented)","title":"命名配置"},{"location":"/routing-dsl/custom-directive.html#转换已存在的指令","text":"第二种方式是通过“转换方法”来转换现有指令，这是在Directive类上定义的方法：\nmap/tmap flatMap/tflatMap require/trequire recover/recoverPF","title":"转换已存在的指令"},{"location":"/routing-dsl/custom-directive.html#map-tmap","text":"map、tmap就和Scala集合库上的map转换类似，它可以将值映射转换成另一个值。map用于Directive1类型的指令（单值指令），而tmap用于值为其它元组的情况，它的签名如下：\ndef tmap[R](f: L => R): Directive[Out]\ntmap可以用来将提取的元组转换成另一个元组，提取的数量和类型都可以改变，而map只用改变变换后的类型。如下是一个虚构的例子：\nval twoIntParameters: Directive[(Int, Int)] =\n  parameters((\"a\".as[Int], \"b\".as[Int]))\n\nval myDirective: Directive1[String] =\n  twoIntParameters.tmap {\n    case (a, b) => (a + b).toString\n  }\n\n// tests:\nGet(\"/?a=2&b=5\") ~> myDirective(x => complete(x)) ~> check {\n  responseAs[String] shouldBe \"7\"\n}","title":"map、tmap"},{"location":"/routing-dsl/custom-directive.html#flatmap-tflatmap","text":"通过map、tmap可以将指令提取的值转换成其它值，但不能改变其“提取”的性质。当需要提取一个对它做一些转换操作，并将结果交给一个嵌套的指令使用时，map、tmap就无能为力了。同map、tmap类似，flatMap也是用于单值指令，而tflatMap用于其它元组值。tflatMap的函数签名如下：\ndef tflatMap[R: Tuple](f: L => Directive[R]): Directive[R]\n可以看一个例子，预定义的method指令，它的定义如下：\ndef method(httpMethod: HttpMethod): Directive0 =\n  extractMethod.flatMap[Unit] {\n    case `httpMethod` => pass\n    case _            => reject(MethodRejection(httpMethod))\n  } & cancelRejections(classOf[MethodRejection])\n\nval get: Directive0 = method(HttpMethods.GET)\nval post: Directive0 = method(HttpMethods.POST)\n通过调用extractMethod指令获取请求的HTTP方法，再通过flatMap[Unit]转换方法对它进行处理。因为extractMethod是一个单值指令且转换后值为Unit（也是个单值），这里调用flatMap方法。 当请求的实际HTTP方法与传入参数httpMethod匹配时，调用pass指令使其通过，否则调用reject(MethodRejection(httpMethod))拒绝。","title":"flatMap、tflatMap"},{"location":"/routing-dsl/custom-directive.html#require-trequire","text":"require方法将单个指令转换为没有提取值的指令，该指令根据谓词函数过滤请求，所有谓词函数调用后为false的请求都被拒绝，其它请求保持不变。它的定义如下：\ndef require(predicate: T => Boolean, rejections: Rejection*): Directive0 =\n  underlying.filter(predicate, rejections: _*).tflatMap(_ => Empty)\n从定义可以看出，它实际上是先通过谓词函数调用filter方法对请求进行过滤，然后再调用tflatMap函数将指令提取的值去掉。","title":"require、trequire"},{"location":"/routing-dsl/custom-directive.html#recover-recoverpf","text":"recover方法允许“捕获”由底层指令向上冒泡产生的rejections，并生成且有相同提取类型的替代指令。这样就可以恢复指令来通过而不是拒绝它。它们的定义分别如下：\ndef recover[R >: L: Tuple](recovery: immutable.Seq[Rejection] => Directive[R]): Directive[R] =\n  Directive[R] { inner => ctx =>\n    import ctx.executionContext\n    @volatile var rejectedFromInnerRoute = false\n    tapply({ list => c => rejectedFromInnerRoute = true; inner(list)(c) })(ctx).fast.flatMap {\n      case RouteResult.Rejected(rejections) if !rejectedFromInnerRoute => recovery(rejections).tapply(inner)(ctx)\n      case x => FastFuture.successful(x)\n    }\n  }\n\ndef recoverPF[R >: L: Tuple](recovery: PartialFunction[immutable.Seq[Rejection], Directive[R]]): Directive[R] =\n  recover { rejections => recovery.applyOrElse(rejections, (rejs: Seq[Rejection]) => RouteDirectives.reject(rejs: _*)) }","title":"recover、recoverPF"},{"location":"/routing-dsl/custom-directive.html#从头开始实现一个指令","text":"可以通过调用Directive.apply或它的子类型来从头开始定义一个指令，Directive的简化定义看起来像下面这样：\nabstract class Directive[L](implicit val ev: Tuple[L]) {\n  def tapply(f: L => Route): Route\n}\n\nobject Directive {\n\n  /**\n   * Constructs a directive from a function literal.\n   */\n  def apply[T: Tuple](f: (T => Route) => Route): Directive[T] =\n    new Directive[T] { def tapply(inner: T => Route) = f(inner) }\n\n}\nDirective类型有一个抽象方法tapply，参数f是一个函数类型，将类型L传入并返回Route。Directive的伴身对象提供了apply函数来实现自定义指令，它的参数是一个高阶函数(T => Route) => Route，就像小括号那样，我们应把（T => Route)看成一个整体，它是函数参数，返回类型为Route。\nf为我们自定义指令用于从RequestContext里提取值（值的类型为Tuple[L]），而inner就是f提取值后调用的嵌套路由，在调用inner时将提取出的值作为参数传入。\n对于一个提取访问host和port的指令，可以这样实现：\ndef hostnameAndPort: Directive[(String, Int)] = Directive[(String, Int)] { inner => ctx =>\n  // inner: (String, Int) => Route\n  // ctx: RequestContext\n\n  val authority: Uri.Authority = ctx.request.uri.authority\n  val tupleValue: (String, Int) = (authority.host.address(), authority.port)\n  val route: Route = inner(tupleValue)\n  route(ctx) // Future[RouteResult]\n}\n让我们来分析下这个例子：\n首先是hostnameAndPort指令的类型Directive[(String, Int)]，它从请求上下文（RequestContext）中提取出的值是Tuple2[String, Int]。 apply方法执行的代码参数是：inner => ctx => ....其实可以看成：inner => ((ctx: RequestContext) => Future[RouteResult])，inner就是f函数参数(T => Route）部分。 inner(tupleValue)执行后结果route的类型是Route，这时这段代码为的类型就为inner => ctx => Route，而实际上Directive.apply需要的参数类型为inner => Route。之前我们知道，Route是一个类型别名RequestContext => Future[RouteResult]，所以我们需要将ctx => Route转换为Route。而将tupleValue作为参数调用route后将获取结果类型Future[RouteResult]，这段代码的类型就是inner => ctx => Future[RouteResult] -> inner => Route。","title":"从头开始实现一个指令"},{"location":"/routing-dsl/rejections.html","text":"","title":"拒绝 rejections"},{"location":"/routing-dsl/rejections.html#拒绝-rejections","text":"TODO","title":"拒绝 rejections"},{"location":"/routing-dsl/exception.html","text":"","title":"异常处理"},{"location":"/routing-dsl/exception.html#异常处理","text":"TODO","title":"异常处理"},{"location":"/routing-dsl/file-upload.html","text":"","title":"实战：大文件断点上传、下载和秒传"},{"location":"/routing-dsl/file-upload.html#实战-大文件断点上传-下载和秒传","text":"本章，使用Akka HTTP和Akka Stream做为后端服务，可以很优雅的实现大文件的断点续传。原理其实非常的简单， 前端计算文件的hash（使用sha256），将hash传到后端查询是否有相同文件已上传，若有将返回已上传文件及文件长度（bytes）。 这时候前端就可以知道文件的上传进度，进而判断还需要断点续传的偏移量或者已上传完成（这就是秒传）。\n这里有一个设计取舍：客户端对单个文件不做分片，从文件头开始上传。这样的一个好处是可简化服务端的实现， 同时也可以优化服务端对文件的存储 （同一个文件将一直使用APPEND的方式写入文件，这样可以更高效的利用磁盘IO。同时， 不需要分块合并，若文件很大，生成的大量分块在文件上传完成后再次合并会是一个非常大的资源开销） 。","title":"实战：大文件断点上传、下载和秒传"},{"location":"/routing-dsl/file-upload.html#断点下载","text":"这个怎么说呢？断点下载Akka HTTP原生支持。你只需要使用如下代码：\n// 支持断点续传\nprivate def downloadRoute: Route = path(\"download\" / Segment) { hash =>\n  getFromFile(FileUtils.getLocalPath(hash).toFile)\n}\nFileUtils.getLocalPath(hash)函数通过对hash值（sha256hex）进行计算和拼接， 获取实际文件的本地存储路径再交给Akka HTTP提供的getFromFile指令，剩下的工作就交给Akka。\ndef getLocalPath(hash: String): Path = Paths.get(LOCAL_PATH, hash.take(2), hash)\n我们可以通过向Akka HTTP发起HEAD请求来查看支持的HTTP功能，看到在反回的header里有Accept-Ranges: bytes， 意思是服务端支持使用字节为单位的范围下载（断点下载功能既基于此实现）。\n$ curl --head http://localhost:33333/file/download/7d0559e2f7bf42f0c2becc7fbf91b20ca2e7ec373c941fca21314169de9c7ef4\nHTTP/1.1 200 OK\nLast-Modified: Fri, 28 Dec 2018 14:12:32 GMT\nETag: \"132766a7f528d080\"\nAccept-Ranges: bytes\nServer: akka-http/10.1.6\nDate: Sat, 29 Dec 2018 02:17:41 GMT\nContent-Type: application/octet-stream\nContent-Length: 65463496\nNote 通过以下sbt task可以启动文件上传示例程序： sbt \"foundation/runMain fileupload.Main\" \n 看到如下输出代表程序启动成功： ......\n[info] Done packaging.\n[info] Running fileupload.Main \nfileupload.Main$ - startup success, ServerBinding(/127.0.0.1:33333)","title":"断点下载"},{"location":"/routing-dsl/file-upload.html#断点上传","text":"很遗憾，Akka HTTP默认不支持断点上传，这需要自行实现。但是，Akka HTTP做为一个toolkit，足够灵活且强大，实现断点上传功能so easy。","title":"断点上传"},{"location":"/routing-dsl/file-upload.html#断点上传实现","text":"基于常规的代码设计方式，我们需要Controller、Service，那就先从Controller开始：","title":"断点上传实现"},{"location":"/routing-dsl/file-upload.html#fileroute-uploadroute","text":"private def uploadRoute: Route = path(\"upload\") {\n  post {\n    withoutSizeLimit {\n      entity(as[Multipart.FormData]) { formData =>\n        onSuccess(fileService.handleUpload(formData)) { results =>\n          import helloscala.http.JacksonSupport._\n          complete(results)\n        }\n      }\n    }\n  }\n}\n这里需要注意的一个指令是withoutSizeLimit，默认Akka HTTP对请求大小限制比较低，我们可以通过withoutSizeLimit 指令取消对单个API的请求大小限制，同时又不影响整个Web服务的大小限制。另外，这里通过entity(as[Multipart.FormData])以 Unmarshaller的方式获取整个Multipart.FormData对象并传入FileService#handleUpload函数进行处理。","title":"FileRoute#uploadRoute"},{"location":"/routing-dsl/file-upload.html#fileservice-handleupload","text":"override def handleUpload(formData: Multipart.FormData): Future[Seq[FileBO]] = {\n  formData.parts\n  //      .groupBy(Constants.FILE_PART_MAX, part => part.name.split('.').head)\n  //      .async\n  //      .foldAsync[FileInfo](FileInfo.Empty)((fileInfo, part) => mergeBodyPart(fileInfo, part))\n  //      .mergeSubstreams\n    .map(part => FileInfo(part))\n    .log(\"fileInfo\", info => logger.debug(s\"fileInfo: $info\"))\n    .mapAsync(Constants.FILE_PART_MAX)(processFile)\n    .runWith(Sink.seq)\n}\nformData.parts是一个Akka Stream流，类型签名为Source[Multipart.FormData.BodyPart, Any]。有关Akka Stream 更详细的资料请参阅Akka Streams官方文档。这里， 每个part都代表FormData的一个字段（对应HTML 5的FormData类型，同时前端需要使用 Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryrP4DAyu31ilqEWmz方式发起请求）。每个part.name 都是用英号逗号分隔的三部分来做为请求的字段名，分别是：<hash>.<content length>.<start position>， 这样我们就可以在不加入任何其它字段的情况下告知服务端当前上传文件的sha256hex计算出的hash值、 文件大小（bytes）和上传起始偏移量。","title":"FileService#handleUpload"},{"location":"/routing-dsl/file-upload.html#fileutils-uploadfile","text":"文件上传的核心逻辑在FileUtils#uploadFile函数：\ndef uploadFile(fileInfo: FileInfo)(implicit mat: Materializer, ec: ExecutionContext): Future[FileBO] = {\n  // TODO 需要校验上传完成文件的hash值与提交hash值是否匹配？\n  val maybeMeta = fileInfo.hash.flatMap(FileUtils.getFileMeta)\n  val beContinue = maybeMeta.isDefined && fileInfo.startPosition > 0L\n  val f = if (beContinue) uploadContinue(fileInfo, maybeMeta.get) else uploadNewFile(fileInfo)\n  f.andThen {\n    case tryValue =>\n      logger.debug(s\"文件上传完成：$tryValue\")\n  }\n}\nuploadFile函数根据是否为续传来分别调用uploadContinue或uploadNewFile函数。首先来看看新文件上传时的代码逻辑：\nprivate def uploadNewFile(fileInfo: FileInfo)(implicit mat: Materializer, ec: ExecutionContext) = {\n  val bodyPart = fileInfo.bodyPart\n  val tmpPath = fileInfo.hash // (1)\n    .map(h => FileUtils.getLocalPath(h))\n    .getOrElse(Files.createTempFile(FileUtils.TMP_DIR, bodyPart.filename.getOrElse(\"\"), \"\"))\n  val sha = MessageDigest.getInstance(\"SHA-256\")\n  logger.debug(s\"新文件，路径：$tmpPath\")\n  bodyPart.entity.dataBytes\n    .map { byteString =>\n      byteString.asByteBuffers.foreach(sha.update) // (2)\n      byteString\n    }\n    .runWith(FileIO.toPath(tmpPath)) // (3)\n    .map { ioResult =>\n      val computedHash = Utils.bytesToHex(sha.digest()) // (4)\n      fileInfo.hash.foreach { h =>\n        require(h == computedHash, s\"前端上传hash与服务端计算hash值不匹配，$h != $computedHash\")\n      }\n      val localPath = fileInfo.hash match { // (5)\n        case Some(_) => tmpPath\n        case _       => move(computedHash, tmpPath, ioResult.count)\n      }\n      FileBO(fileInfo.hash, Some(computedHash), localPath, ioResult.count, bodyPart.filename, bodyPart.headers)\n    }\n}\n根据前端是否上传了有效的hash值（sha256hex）来判断是把文件先写入临时文件还是直接写入实际的本地存储位置（根据hash值计算出本地实际的存储位置）。 Akka HTTP中，上传的文件以流的方式进入，在此对每个ByteString计算并更新sha256值。 在Akka Stream的Sink端，接收流传入的元素并写入本地文件。 文件写入结束后调用sha.digest()方法获取已上传文件的sha256值。 根据是否临时文件来判断是否需要将临时文件移动到实际的本地存储路径，通过文件的hash值来计算出实际的本地存储路径。\n断点上传时的逻辑其实相对简单，需要注意的是在(1)处调用FileIO.toPath将流定入本地时需要以APPEND模式追加写入到已存在文件。\nprivate def uploadContinue(fileInfo: FileInfo, meta: FileMeta)(implicit mat: Materializer, ec: ExecutionContext) = {\n  val bodyPart = fileInfo.bodyPart\n  val localPath = FileUtils.getLocalPath(fileInfo.hash.get)\n  logger.debug(s\"断点续传，startPosition：${fileInfo.startPosition}，路径：$localPath\")\n  bodyPart.entity.dataBytes\n    .runWith(FileIO.toPath(localPath, Set(APPEND), fileInfo.startPosition))\n    .map(ioResult =>\n      FileBO(fileInfo.hash, None, localPath, meta.size + ioResult.count, bodyPart.filename, bodyPart.headers))\n}","title":"FileUtils#uploadFile"},{"location":"/routing-dsl/file-upload.html#秒传","text":"在已实现断点上传功能之上，秒传的实现逻辑就非常清晰了。客户端在调用file/upload接口上传文件之前先调用/file/progress/{hash}接口判断相同hash值文件的上传情况，再决定下一步处理。\n客户端计算文件hash，并以文件hash和文件大小作为参数调用/file/progress/{hash}接口 服务端根据上传hash值判断文件是否已上传，若存在返回已上传文档大小（bytes） 客户端收到服务端响应后根据文件是否存在及已存在文件大小判断**秒传**、**断点续传**还是**新上传** 秒传，返回文件长度与当前准备上传文件长度大小一致 断点续传，返回文件大小比当前准备上传文件长度小 新上传，返回文件不存在 其它情况，作为新文件上传\n秒传的代码逻辑台下：\nprivate def uploadRoute: Route = path(\"upload\") {\n  post {\n    withoutSizeLimit {\n      entity(as[Multipart.FormData]) { formData =>\n        onSuccess(fileService.handleUpload(formData)) { results =>\n          import helloscala.http.JacksonSupport._\n          complete(results)\n        }\n      }\n    }\n  }\n}\n文件上传进度服务实现如下。\noverride def progressByHash(hash: String): Future[Option[FileMeta]] = {\n  require(Objects.nonNull(hash) && hash.nonEmpty, \"hash 不能为空。\")\n  Future.successful(FileUtils.getFileMeta(hash))\n}","title":"秒传"},{"location":"/routing-dsl/file-upload.html#运行示例","text":"通过以下sbt task可以启动文件上传示例程序：sbt \"foundation/runMain fileupload.Main\"。启动示例程序后， 打开浏览器输入地址：http://localhost:33333/file-upload/upload.html 可访问大文件上传示例页面。","title":"运行示例"},{"location":"/routing-dsl/file-upload.html#小结","text":"本文以Akka HTTP和HTML 5讲述了怎样实现一个支持大文件断点上传、下载和秒传的示例应用程序。","title":"小结"},{"location":"/directives/index.html","text":"","title":"常用指令"},{"location":"/directives/index.html#常用指令","text":"Akka HTTP已经预定义了大量的指令，应用开发时可以直接使用。若现存的指令不能满足我们的需求，Akka HTTP也提供了自定义指令的方法。\nAkka HTTP的所有预定义指令都可以通过混入Directives trait或导入Directives._来访问。\nclass MyRoute extends Directives {\n  ....\n}\n\nclass MyRoute {\n  import Directives._\n  ....\n}\nDirectives按功能分成了很多经类，完成的指令分类和说明见官方文档：https://doc.akka.io/docs/akka-http/current/routing-dsl/directives/by-trait.html。这里我们着重介绍下日常开发工作中经常使用到的指令。\nPathDirectives（路径指令） Path示例 深入Uri.Path 深入PathMatcher 常用基本的PathMatcher 组合子（Combinators） 修饰符 directives/method.html directives/parameter_form.html directives/marshalling.html directives/file.html directives/cookie.html","title":"常用指令"},{"location":"/directives/path.html","text":"","title":"PathDirectives（路径指令）"},{"location":"/directives/path.html#pathdirectives-路径指令-","text":"以指定的路径与RequestContext.unmatchedPath进行匹配，当匹配成功时可选提取一个或多个值（提取值的类型由指定的路径参数决定）。若匹配失败，将调用reject拒绝此次请求。它处理的类型为：Uri.Path（之后简称Path）。\n官方文档：https://doc.akka.io/docs/akka-http/current/routing-dsl/directives/path-directives/index.html\n最常会用到的路径指令有：pathPrefix、path、pathEnd和pathEndOrSingleSlash。\npathPrefix：对于路径：/user/page，指令pathPrefix(\"user\")将先与第一个’/’匹配，再匹配user，然后将剩余部分/page设置到RequestContext.unmatchedPath。pathPrefix(X)只与路径的前缀部分匹配X。\npath：对于路径：/page，指令path(\"page\")将先与’/’匹配，再匹配page，同时剩余部分应为空，它将RequestContext.unmatchedPath设置为Path.Empty。path(X)会与路径进行完整匹配。\npathEnd：pathEnd是一个没有参数的指令，将在剩余路径为Path.Empty时匹配成功。它常用于在嵌套路由下匹配父路由已经完全匹配的路径（unmatchedPath为Path.Empty）。\npathEndOrSingleSlash：类似pathEnd，但它还会在剩余路径为Slash（路径为’/’）时也匹配成功。\n注意 对于希望只匹配URI的一部分，而将剩余部分委托给嵌套路由（子路由）时必需使用pathPrefix指令。只有当确定嵌套部分不再对URI进行匹配操作时才使用path指令。因此，将一个path或path指令嵌套在一个path指令下，它是永远不会被匹配上的。因为这时候RequestContext.unmatchedPath为空。","title":"PathDirectives（路径指令）"},{"location":"/directives/path.html#path示例","text":"// 路由：\nval route =\n  path(\"foo\") {\n    complete(\"/foo\")\n  } ~\n    path(\"foo\" / \"bar\") {\n      complete(\"/foo/bar\")\n    } ~\n    pathPrefix(\"ball\") {\n      pathEnd {\n        complete(\"/ball\")\n      } ~\n        path(IntNumber) { int =>\n          complete(if (int % 2 == 0) \"even ball\" else \"odd ball\")\n        }\n    }\n\n// 测试：\nGet(\"/\") ~> route ~> check {\n  handled shouldEqual false\n}\n\nGet(\"/foo\") ~> route ~> check {\n  responseAs[String] shouldEqual \"/foo\"\n}\n\nGet(\"/foo/bar\") ~> route ~> check {\n  responseAs[String] shouldEqual \"/foo/bar\"\n}\n\nGet(\"/ball/1337\") ~> route ~> check {\n  responseAs[String] shouldEqual \"odd ball\"\n}","title":"Path示例"},{"location":"/directives/path.html#深入uri-path","text":"Uri.Path是一个递归数据结构，类似Scala集合类型List，它的简化版定义如下：\nsealed abstract class Path {\n    type Head // head的类型由实现类定义，可能是`Char`，也可能是`String`\n    def isEmpty: Boolean\n    def startsWithSlash: Boolean\n    def startsWithSegment: Boolean\n    def endsWithSlash: Boolean\n    def head: Head // 路径链表头\n    def tail: Path // 路径链表剩余部分\n    def length: Int // 整个路径链表长度，包括解码字符和路径段\n    def charCount: Int // 整个路径链里解码字符的数量\n    def ::(c: Char): Path = { require(c == '/'); Path.Slash(this) }\n    def ::(segment: String): Path\n    def +(pathString: String): Path = this ++ Path(pathString)\n    def ++(suffix: Path): Path\n    def /(segment: String): Path = this ++ Path.Slash(segment :: Path.Empty)\n    def ?/(segment: String): Path = if (this.endsWithSlash) this + segment else this / segment\n    def dropChars(count: Int): Path // 从链表头部开始，去看count个解码字符，同时解码字符间的路径段也一起被去掉\n  }\n名词解释 解码字符：URI通过’/‘符合分隔，路径需要使用’/’都需要对其进行encode。在Akka HTTP里抽象为Slash类型。 路径段：URI字符串是被解码字符分隔出来的字符串。在Akka HTTP里抽象为Segment类型。\nPath定义为抽象类，它的具体实现类有三个：Empty、Slash、Segment，而Empty继承于SlashOrEmpty。\nSlashOrEmpty：路径为解码字符’/’或空 sealed abstract class SlashOrEmpty extends Path {\n  def startsWithSegment = false\n}\n Empty：路径为空 case object Empty extends SlashOrEmpty {\n  type Head = Nothing\n  def isEmpty = true\n  def startsWithSlash = false\n  def head: Head = throw new NoSuchElementException(\"head of empty path\")\n  def tail: Path = throw new UnsupportedOperationException(\"tail of empty path\")\n}\n Slash：路径为解码字符’/’ final case class Slash(tail: Path) extends SlashOrEmpty {\n  type Head = Char\n  def head = '/'\n}\n Segment：路径为字符串，URI里面实际的路径段。 final case class Segment(head: String, tail: SlashOrEmpty) extends Path {\n  if (head.isEmpty) throw new IllegalArgumentException(\"Path segment should not be empty\")\n  type Head = String\n}","title":"深入Uri.Path"},{"location":"/directives/path.html#深入pathmatcher","text":"当一个HTTP请求（若确切地说一个RequestContext实例）进行路由结构时，它有一个与request.uri.path相同类型的unmatchedPath。当RequestContext通过路由树向下传播，通过一个或多个pathPrefix或者path路径时，unmatchedPath的左边被逐渐“吃掉”。\n在每个指令中，都由路径匹配DSL来精确地进行匹配并从中提取需要的内容。路径匹配DSL围绕着以下类型构建：\ntrait PathMatcher[L: Tuple]\ntype PathMatcher0 = PathMatcher[Unit]\ntype PathMatcher1[T] = PathMatcher[Tuple1[T]]\ntype PathMatcher2[T,U] = PathMatcher[Tuple2[T,U]]\n// .. 等等\nPathMatcher的实例对unmatchedPath进行精确的匹配和提取值，提取值的数量和类型由泛型参数L表示，L需要是Scala的Tuple或Unit类型之五（由Tuple上下文绑定限定）。\n看一个较复杂的例子：\nval matcher: PathMatcher1[Option[Int]] =\n  \"foo\" / \"bar\" / \"X\" ~ IntNumber.? / (\"edit\" | \"create\")\nmatcher将匹配/foo/bar/X32/edit或者/foo/bar/X/create。\"X\" ~ IntNumber.?的意思是匹配一个X字符加0个或多个十进制整数字符，同时所有整数字符全在一起数值取值范围为**int32**。\n注意 路径匹配DSL在匹配URI路径以后才对已匹配部分进行解码。这意味着路径分隔符不能写到字符串中，必需使用/函数来定义，不然字符串\"foo/bar\"将匹配原始的字符串\"foo%2fbar\"，这应该不是你想要的。","title":"深入PathMatcher"},{"location":"/directives/path.html#常用基本的pathmatcher","text":"一个路径匹配器可以通过组合或修改多个基本的PathMatcher来构造，以下是常用的基本PathMatcher。\n字符串\nString的实例可以作为PathMatcher0。字符串只匹配自身，不提取任何值。需要注意的是字符串被解释为路径的解码表示（decode），当它包含一个’/‘字符时，这个字符将与编码的原始URI中的’%2f’进行匹配。\n正则表达式\nRegex的实例可以作为PathMatcher1[String]。正则表达式不包含捕获组时将提取完整匹配或者只包含一个捕获组时提取捕获的内容，若正则表达式包含多个捕获组，则将引发IllegalArgumentException异常。\nSegment: PathMatcher1[String]\n从路径段不以’/’斜线开始匹配，将匹配的部分提取为字符串。\nIntNumber: PathMatcher1[Int]\n匹配一个或多个十进制字符为非负的Int数值。\nLongNumber: PathMatcher1[Long]\n匹配一个或多个十进制字符为非负的Long数值。","title":"常用基本的PathMatcher"},{"location":"/directives/path.html#组合子-combinators-","text":"Path的路径匹配器（Matcher）可以组合起来形成更高级的结构。\n~ 操作符\n~操作符可以将两个Matcher指令连接起来。它将两个Matcher连接成一个，同时还保持Matcher的类型安全。如：\"foo\" ~ \"bar\" 等价于 \"foobar\"。\n/ 操作符\n/操作符连接两个Matcher，并在中间插入 Slash（/） 匹配器。如：\"foo\" / \"bar\" 等价于 \"foo\" ~ Slash ~ \"bar\"。\n| 操作符\n|操作符组合了两个Matcher的方案，当且第一个不匹配时才尝试第二个，且两个Matcher必须具有兼容的类型。如：(\"foo\" | \"bar\") / \"bom\"将先匹配/foo/bom路由，再匹配/bar/bom路由（‘/’的优先级比’|’高，所以这里需要使用小括号括起来）。","title":"组合子（Combinators）"},{"location":"/directives/path.html#修饰符","text":"‘/’和’?’可作为修饰符作用于Matcher上，如下所示：\n// 匹配 /foo/\npath(\"foo\"./)\n\n// 匹配 /foo/bar\npath(\"foo\" / \"bar\")\n\n// 注意: 匹配 /foo%2Fbar 而不是 /foo/bar\npath(\"foo/bar\")\n\n// 匹配 /foo/bar\npath(separateOnSlashes(\"foo/bar\"))\n\n// 匹配 /foo/123 等 并抽取 \"123\" 作为字符串类型的抽取值\npath(\"foo\" / \"\"\"\\d+\"\"\".r)\n\n// 匹配 /foo/bar123 并抽取 \"123\" 作为字符串类型的抽取值\npath(\"foo\" / \"\"\"bar(\\d+)\"\"\".r)\n\n// 类似 `path(Segments)`\npath(Segment.repeat(10, separator = Slash))\n\n// 匹配 /i42 等 或者 /hCAFE 等，并抽取值为Int类型\npath(\"i\" ~ IntNumber | \"h\" ~ HexIntNumber)\n\n// 等价于 path(\"foo\" ~ (PathEnd | Slash))\npath(\"foo\" ~ Slash.?)\n\n// 匹配 /red 或 /green 或 /blue 并分别抽取 1, 2 或 3\npath(Map(\"red\" -> 1, \"green\" -> 2, \"blue\" -> 3))\n\n// 匹配任何以 /foo 开头且不以 /foobar 开头的路径\npathPrefix(\"foo\" ~ !\"bar\")","title":"修饰符"},{"location":"/directives/method.html","text":"","title":"· Scala Web 开发——基于Akka HTTP"},{"location":"/directives/parameter_form.html","text":"","title":"· Scala Web 开发——基于Akka HTTP"},{"location":"/directives/marshalling.html","text":"","title":"· Scala Web 开发——基于Akka HTTP"},{"location":"/directives/file.html","text":"","title":"· Scala Web 开发——基于Akka HTTP"},{"location":"/directives/cookie.html","text":"","title":"· Scala Web 开发——基于Akka HTTP"},{"location":"/data/index.html","text":"","title":"数据"},{"location":"/data/index.html#数据","text":"本章代码见：https://github.com/yangbajing/scala-web-development/tree/master/data\n数据 JSON Jackson JacksonSupport 在 routing DSL 里使用 总结 实战：为Ant Design Pro提供后端接口 设置 Ant Design Pro 打包、部署 总结 Kryo Protobuf 小结","title":"数据"},{"location":"/data/data.0.html","text":"","title":"数据"},{"location":"/data/data.0.html#数据","text":"","title":"数据"},{"location":"/data/data.1.html","text":"","title":"JSON"},{"location":"/data/data.1.html#json","text":"","title":"JSON"},{"location":"/data/data.1.html#jackson","text":"Jackson 是Java生态圈里最流行的JSON序列化库，它的官方网站是：https://github.com/FasterXML/jackson。\n为什么选择 Jackson 为什么选择 Jackson 而不是更Scala范的 play-json、 circe、 json4s 等JSON序列化库呢？这里主要考虑是 Jackson 在Java生态圈里更流行，相对熟悉的人更多，可以一定程度上减轻Javaer们使用Scala时上手的难度。 同时，Jackson支持对大部分Java和Scala下的集合库、数据类型的JSON序列化，而大部分Scala范的JSON库只支持Scala的集合库、case class和数据类型。当你的应用里同时使用Java和Scala两种不同的集合类型和Java style class与Scala case class时，Jackson都可以对其完美支持。","title":"Jackson"},{"location":"/data/data.1.html#jacksonsupport","text":"基于 Akka HTTP 的 marshal/unmarshal 机制，可以很容易的集成各种序列化/反序列化工具。akka-http-json 这套库就提供了9种不同的JSON序列化/反序列化方安供用户选择。\n我们需要在 sbt 里添加依赖：\nlibraryDependencies += \"de.heikoseeberger\" %% \"akka-http-jackson\" % \"1.22.0\"","title":"JacksonSupport"},{"location":"/data/data.1.html#使用默认的-akka-http-jackson","text":"\"Default ObjectMapper\" should {\n  import de.heikoseeberger.akkahttpjackson.JacksonSupport._\n\n  \"从case class序列化和反序列化\" in {\n    val foo = Foo(\"bar\", 2018)\n    val result = Marshal(foo).to[RequestEntity].flatMap(Unmarshal(_).to[Foo]).futureValue\n    foo shouldBe result\n  }\n\n  \"从数组case class序列化和反序列化\" in {\n    val foos = Seq(Foo(\"bar\", 2018))\n    val result = Marshal(foos).to[RequestEntity].flatMap(Unmarshal(_).to[Seq[Foo]]).futureValue\n    foos shouldBe result\n  }\n\n  \"不支持OffsetDateTime\" in {\n    val foo = FooTime(\"羊八井\", OffsetDateTime.now())\n    val requestEntity = Marshal(foo).to[RequestEntity].futureValue\n    intercept[MismatchedInputException] {\n      throw Unmarshal(requestEntity).to[Foo].failed.futureValue\n    }\n  }\n}\n可以看到，默认的 akka-http-jackson 不支持 Java 8 新提供的时间/日期类型序列化，这是因为它默认使用的 Jackson ObjectMapper 没有加载 JavaTimeModule 这个模块在 https://github.com/FasterXML/jackson-modules-java8/tree/master/datetime 可以找到JavaTimeModule这个模块的更多详细说明。\n/**\n  * Automatic to and from JSON marshalling/unmarshalling usung an in-scope Jackon's ObjectMapper\n  */\nobject JacksonSupport extends JacksonSupport {\n\n  val defaultObjectMapper: ObjectMapper =\n    new ObjectMapper().registerModule(DefaultScalaModule)\n}","title":"使用默认的 akka-http-jackson"},{"location":"/data/data.1.html#通过隐式值使用自定义的-objectmapper","text":"首先来看看 akka-http-jackson 定义的 JacksonSupport.scala，它通过两个隐式函数实现了 Akka HTTP 的 Marshal/Unmarshal 功能。\n/**\n    * HTTP entity => `A`\n    */\n  implicit def unmarshaller[A](\n      implicit ct: TypeTag[A],\n      objectMapper: ObjectMapper = defaultObjectMapper\n  ): FromEntityUnmarshaller[A] =\n    jsonStringUnmarshaller.map(\n      data => objectMapper.readValue(data, typeReference[A]).asInstanceOf[A]\n    )\n\n  /**\n    * `A` => HTTP entity\n    */\n  implicit def marshaller[Object](\n      implicit objectMapper: ObjectMapper = defaultObjectMapper\n  ): ToEntityMarshaller[Object] =\n    Jackson.marshaller[Object](objectMapper)\n可以看到隐式函数又分别定义了两个和一个隐式参数，而 objectMapper: ObjectMapper = defaultObjectMaper这个隐式参数定义了默认值，这样在使用时我们就可以提供自定义的 ObjectMapper 来替代默认的 defaultObjectMapper。先来看看怎样使用自定义的 ObjectMapper：\n\"Custom ObjectMapper\" should {\n  import de.heikoseeberger.akkahttpjackson.JacksonSupport._\n  implicit val objectMapper: ObjectMapper = helloscala.common.json.Jackson.defaultObjectMapper\n\n  \"支持OffsetDateTime\" in {\n    val foo = FooTime(\"羊八井\", OffsetDateTime.now())\n    val requestEntity = Marshal(foo).to[RequestEntity].futureValue\n    val result = Unmarshal(requestEntity).to[FooTime].futureValue\n    foo shouldBe result\n  }\n\n  \"从数组case class序列化和反序列化\" in {\n    val foos = Seq(FooTime(\"羊八井\", OffsetDateTime.now()))\n    val results = Marshal(foos).to[RequestEntity].flatMap(Unmarshal(_).to[Seq[FooTime]]).futureValue\n    foos shouldBe results\n  }\n}\n通过在代码上下文中定义一个隐式值：implicit val objectMapper: ObjectMapper = .... （变量名可以取任何名字，不需要是objectMapper。但是需要保证在代码上下文中只有一个ObjectMapper隐式类型。），Scala 编译器在编译代码时将使用定义的隐式值传入函数 unmarshaller 或 marshaller 中以替代函数定义时设置的默认值。\n自定义 ObjectMapper 定义在object Jackson.scala：\nimplicit val defaultObjectMapper: ObjectMapper = getObjectMapper\n\nprivate def getObjectMapper: ObjectMapper = {\n  new ObjectMapper()\n  val FILTER_ID_CLASS: Class[GeneratedMessage] = classOf[GeneratedMessage]\n  new ObjectMapper()\n    .setFilterProvider(new SimpleFilterProvider()\n      .addFilter(FILTER_ID_CLASS.getName, SimpleBeanPropertyFilter.serializeAllExcept(\"allFields\")))\n    .setAnnotationIntrospector(new JacksonAnnotationIntrospector() {\n      override def findFilterId(a: Annotated): AnyRef =\n        if (FILTER_ID_CLASS.isAssignableFrom(a.getRawType)) FILTER_ID_CLASS.getName else super.findFilterId(a)\n    })\n    .findAndRegisterModules\n    //.setDateFormat(new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"))\n    //.enable(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY)\n    .enable(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES)\n    .enable(JsonParser.Feature.ALLOW_SINGLE_QUOTES)\n    .enable(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)\n    .enable(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)\n    .disable(DeserializationFeature.FAIL_ON_IGNORED_PROPERTIES)\n    .disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)\n    .disable(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE) // 禁止反序列化时将时区转换为 Z\n    .disable(SerializationFeature.FAIL_ON_EMPTY_BEANS) // 允许序列化空的对象\n    .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS) // 日期时间类型不序列化成时间戳\n    .disable(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS) // 日期时间类型不序列化成时间戳\n    .setSerializationInclusion(JsonInclude.Include.NON_NULL) // 序列化时不包含null的键","title":"通过隐式值使用自定义的 ObjectMapper"},{"location":"/data/data.1.html#自定义反序列化时允许的mediatype类型","text":"默认情况下，JacksonSupport要求客户端提交的HTTP请求必需设置Content-Type的mime-type类型为：application/json，但很多时候会遇到不那么规范的客户端，它们并未正确的设置HTTP请求头。这时我们可以自定义JacksonSupport让它在反序列化时支持其它Content-Type：这里定义除了application/json外还支持text/plain类型的请求。\n\"Custom unmarshallerContentTypes\" should {\n  final object CustomJacksonSupport extends JacksonSupport {\n    override def unmarshallerContentTypes: immutable.Seq[ContentTypeRange] =\n      List(MediaTypes.`text/plain`, MediaTypes.`application/json`)\n  }\n\n  \"text/plain unmarshal failed\" in {\n    import de.heikoseeberger.akkahttpjackson.JacksonSupport._\n    val entity = HttpEntity(\"\"\"{\"name\": \"羊八井\", \"since\": 2018}\"\"\")\n    entity.contentType.mediaType shouldBe MediaTypes.`text/plain`\n    intercept[UnsupportedContentTypeException] {\n      throw Unmarshal(entity).to[Foo].failed.futureValue\n    }\n  }\n\n  \"text/plain unmarshal\" in {\n    import CustomJacksonSupport._\n    val entity = HttpEntity(\"\"\"{\"name\": \"羊八井\", \"since\": 2018}\"\"\")\n    entity.contentType.mediaType shouldBe MediaTypes.`text/plain`\n    val foo = Unmarshal(entity).to[Foo].futureValue\n    foo shouldBe Foo(\"羊八井\", 2018)\n  }\n}","title":"自定义反序列化时允许的MediaType类型"},{"location":"/data/data.1.html#在-routing-dsl-里使用","text":"在 Akka HTTP Routing DSL 里使用Jackson来反序列化/序列化JSON就非常简单了。通过entity(as[FooTime])指令来将提交的JSON数据解析成 FooTime 样本类（将调用 unmarshaller[A] 隐式函数），在complete函数响应结果时将 FooTime 对象序列化成JSON字符串并设置对应的Content-Type（调用 marshaller[A] 隐式函数）。\n\"routing-dsl\" should {\n  import akka.http.scaladsl.server.Directives._\n  import de.heikoseeberger.akkahttpjackson.JacksonSupport._\n  implicit val objectMapper: ObjectMapper = helloscala.common.json.Jackson.defaultObjectMapper\n\n  val route: Route = path(\"api\") {\n    post {\n      entity(as[FooTime]) { foo =>\n        complete(foo.copy(since = foo.since.plusYears(1)))\n      }\n    }\n  }\n\n  \"post json\" in {\n    val foo = FooTime(\"羊八井\", OffsetDateTime.now())\n    Post(\"/api\", foo) ~> route ~> check {\n      status shouldBe StatusCodes.OK\n      contentType.mediaType shouldBe MediaTypes.`application/json`\n      val payload = responseAs[FooTime]\n      foo.name shouldBe payload.name\n      foo.since.isBefore(payload.since) shouldBe true\n    }\n  }\n}","title":"在 routing DSL 里使用"},{"location":"/data/data.1.html#总结","text":"Akka HTTP通过强大的 Marshal/Unmarshal 机制来实现数据的序列/反序列化，作为一款工具库 Akka HTTP 提供了足够的灵活性，用户可以选择自己喜欢的序列/反序列化工具和使用方式。对于JSON，推荐从 https://github.com/hseeberger/akka-http-json 开始，上面很有可能找到你想要的。同时，akka-http-json也是一个不错的学习 Akka HTTP Marshal/Unmarshal 机制的样例。\n完整的测试代码在：data/src/test/scala/scalaweb/data/json/jackson/JacksonSupportTest.scala，可以通过以下命令来运行它：\nsbt \"data/testOnly scalaweb.data.json.jackson.JacksonSupportTest\"\n测试结果示例：","title":"总结"},{"location":"/data/data.ant-design-pro.html","text":"","title":"实战：为Ant Design Pro提供后端接口"},{"location":"/data/data.ant-design-pro.html#实战-为ant-design-pro提供后端接口","text":"之前章节已经了解了Akka HTTP的路由定制、数据序列化等内容，是时候开始一个比较完整的Web应用示例了。这里我们将使用 Akka HTTP 来集成 Ant Design Pro ，Ant Design Pro是一个开箱即用的中台前端/设计解决方案，它由蚂蚁金服开发，官方地址：https://pro.ant.design/index-cn。\n本文假定用户已经熟悉并会使用 Ant Design Pro，若还未接触过可以从官方文档开始：https://pro.ant.design/docs/getting-started-cn。\n本文使用 Ant Design Pro 2.0版本","title":"实战：为Ant Design Pro提供后端接口"},{"location":"/data/data.ant-design-pro.html#设置-ant-design-pro","text":"Ant Design Pro 已经是一个完整的后台前端应用，我们只需要使用 Akka HTTP 为其提供后端API接口服务支持和静态资源文件的HTTP获取功能。","title":"设置 Ant Design Pro"},{"location":"/data/data.ant-design-pro.html#创建api","text":"Akka HTTP 的 Routing DSL 是从上到下一级一级的匹配路由的，当前一个路由不匹配时才判断下一个路由，这样一直到最后一个。利用这个特性，我们可以在整个路由定义的最后来设置返回React SPA需要的静态资源文件。\ndef route: Route =\n  pathPrefix(\"api\") {\n    pathGet(\"currentUser\") {\n      complete(Mocks.apiCurrentUser)\n    } ~\n    pathGet(\"fake_chart_data\") {\n      complete(Mocks.apiFakeChartData)\n    } ~\n    pathGet(\"tags\") {\n      complete(Mocks.apiTags)\n    } ~\n    pathGet(\"activities\") {\n      complete(Mocks.apiActivities)\n    } ~\n    pathGet(\"fake_list\") {\n      parameter('count.as[Int]) { count =>\n        complete(Mocks.apiFakeList(count))\n      }\n    } ~\n    pathPrefix(\"project\") {\n      pathGet(\"notice\") {\n        complete(Mocks.project.notice)\n      }\n    }\n  } ~\n  notPathPrefixTest(\"api\") {\n    getFromResourceDirectory(\"dist\") ~\n    getFromResource(\"dist/index.html\")\n  }\n这里的重点在 notPathPrefixTest(api) { .... } 部分，这一块代码是用来返回 Ant Design Pro 静态资源的。首先它将判断请求URI不是以 /api 开头，若请求URI以/api开关则不进入里面的获取静态资源代码逻辑，而是直接返回一个预定义的指令：reject。通常，我们都会将API接口统一到 /api 这样的路径下，这样非 /api 开头的URI请求就可以交到下面的两句代码执行，来实现SPA应用在资源未找到时服务端默认返回 /index.html 的需求。\ngetFromResourceDirectory(\"dist\") ~\n  getFromResource(\"dist/index.html\")\ngetFromResourceDirectory：根据URI请求路径从资源目录dist查找文件并返回 getFromResource：直接返回 dist/index.html 资源文件\n总体上，以上两个指令组合使用就可以实现类似 Nginx 的 try_files $uri /index.html; 效果\nMocks.scala，定义了API接口数据并组装成 HttpEntity 对象。\nobject project {\n  def notice = toJsonEntity(Project.notice)\n}\ndef apiCurrentUser = toJsonEntity(Api.currentUser)\ndef apiFakeChartData = toJsonEntity(Api.fake_chart_data)\ndef apiTags = toJsonEntity(Api.tags)\ndef apiActivities = toJsonEntity(Api.activities)\n\ndef toJsonEntity(str: String): HttpEntity.Strict = HttpEntity(ContentTypes.`application/json`, str)\n这里为了演示Akka HTTP与Ant Design Pro的集成，我并未直接去实现后端接口数据模型的生成逻辑，比如：model定义、数据存储操作等。而是通过直接返回字符串形式的JSON数据来模拟：\nval currentUser =\n  \"\"\"{\"name\":\"羊八井\",\"avatar\":\"https://gw.alipayobjects.com/zos/rmsportal/BiazfanxmamNRoxxVxka.png\",\"userid\":\"00000001\",\"email\":\"yangbajing@gmail.com\",\"signature\":\"海纳百川，有容乃大\",\"title\":\"一个好爸爸\",\"group\":\"华龙海数－某某某事业群－某某平台部－某某技术部－Developer\",\"tags\":[{\"key\":\"0\",\"label\":\"很有想法的\"},{\"key\":\"1\",\"label\":\"专注后端\"},{\"key\":\"2\",\"label\":\"强~\"},{\"key\":\"3\",\"label\":\"彪悍\"},{\"key\":\"4\",\"label\":\"重庆崽儿\"},{\"key\":\"5\",\"label\":\"海纳百川\"}],\"notifyCount\":12,\"country\":\"China\",\"geographic\":{\"province\":{\"label\":\"重庆市\",\"key\":\"330000\"},\"city\":{\"label\":\"渝北区\",\"key\":\"402260\"}},\"address\":\"渝北区金开大道西段106号10栋移动新媒体产业大厦11楼\",\"phone\":\"023-88888888\"}\"\"\"\n通过def toJsonEntity(str: String): HttpEntity.Strict = HttpEntity(ContentTypes.application/json, str)函数，将JSON字符串实例化为一个HttpEntity对象并设置Content-Type为application/json类型。\n注意 这里只定义了Ant Design Pro的 dashboard 栏目下3个页面需要的接口，其它接口并未实现，因为对于这个示例它们并不是重点。","title":"创建API"},{"location":"/data/data.ant-design-pro.html#添加webpack-proxy支持","text":"修改 ant-design-pro/web/config/config.js 文件，在末尾右大括号（}）上方添加 proxy 设置API代理访问路径路径。这样所有的前端Ajax请求（请求/api开始的路径）都会被路由到Akka HTTP提供的API服务上。\nproxy: {\n    '/api': {\n      target: 'http://localhost:22222',\n      changeOrigin: true,\n    },\n  },\n使用 start:no-mock 启动Ant Design Pro\nnpm run start:no-mock\n打开浏览器，访问 http://localhost:8000 地址：\n这时还未启动Akka HTTP后端服务，看到在请求后端API /api/currentUser时报504网关超时错误。这代表我们设置的 webpack.proxy 已经生效，接下来让我们启动Akka HTTP后端服务。","title":"添加webpack proxy支持"},{"location":"/data/data.ant-design-pro.html#启动akka-http-server","text":"Main.scala\nobject Main extends App with StrictLogging {\n  implicit val system = ActorSystem()\n  implicit val materializer = Materializer(system)\n  import system.dispatcher\n\n  val bindingFuture = Http().bindAndHandle(handler = new Routes().route, interface = \"0.0.0.0\", port = 22222)\n\n  bindingFuture.onComplete {\n    case Success(binding) =>\n      sys.addShutdownHook(system.terminate())\n      logger.info(s\"启动Akka HTTP Server成功，绑定地址: $binding\")\n    case Failure(e) =>\n      logger.error(s\"启动Akka HTTP Server失败：${e.getMessage}\", e)\n      system.terminate()\n  }\n\n}\n可以看到，编程启动Akka HTTP服务非常简单。我们执行Main.scala即可启动Akka HTTP服务。看到类似输出就代表服务已经启动成功：\n10:59:13.659 [default-akka.actor.default-dispatcher-4] INFO scalaweb.ant.design.pro.Main$ - 启动Akka HTTP Server成功，绑定地址: ServerBinding(/0:0:0:0:0:0:0:0:22222)","title":"启动Akka HTTP Server"},{"location":"/data/data.ant-design-pro.html#打包-部署","text":"Ant Design Pro 的 Akka HTTP集成已经完成，我们也在开发模式下分别启动了Webpack Dev Server和Akka HTTP Server来看到我们集成的效果。要把集成的成果部署到服务器上怎么办？非常的简单，执行如下的几行命令就可以生成一个同时提供后端API接口和HTTP静态资源渲染的独立可执行jar包。不需要使用Nginx/Apache的代理静态资源，这样部署更加简洁。当然，你也可以继续使用用Nginx/Apache来代理静态资源，如果需要的话。\npushd ant-design-pro/web\nyarn install\nyarn run build\npopd\nrm -rf ant-design-pro/src/main/resources/dist/*\ncp ant-design-pro/web/dist/* ant-design-pro/src/main/resources/dist/\nsbt \"project ant-design-pro\" assembly\n首先编译 Ant Design Pro，在 dist 目录生成静态资源。 copy所有静态资源到 resources/dist 目录，这样Akka HTTP可以在生成的jar里通过Java资源文件机制访问到它们。 使用 sbt assembly 命令打包。 使用 java -jar 命令执行可执行jar包文件。\n运行程序\njava -jar ant-design-pro/target/scala-2.12/ant-design-pro-assembly-1.0.0.jar\n打开浏览器访问 http://localhost:22222/ 即可看到 Ant Design Pro 的界面。\n示例效果","title":"打包、部署"},{"location":"/data/data.ant-design-pro.html#总结","text":"我们通过一个简单的实战示例：ant-desigin-pro，将之前几章所讲知识串起来通过Akka HTTP技术实现了一个较为完整的Web应用。\n本章源码在：https://github.com/yangbajing/scala-web-development/tree/master/ant-design-pro","title":"总结"},{"location":"/data/data.kryo.html","text":"","title":"Kryo"},{"location":"/data/data.kryo.html#kryo","text":"Kryo是一种快速高效的用于Java的二进制对象图序列化框架。具有调整、压缩率高和易于使用的特性。\n在Akka中使用Kryo可以采用Twitter开源的 chill 库，它可以简化对Kryo的使用并对Scala有着更友好的API。\n在Akka里使用chill非常的简单，首先需要引入相关库依赖：\nlibraryDependencies += \"com.twitter\" %% \"chill-akka\" % \"0.9.3\"\n在修改Akka配置：\nakka.actor {\n  # 启用附加的自定义序列化绑定功能\n  enable-additional-serialization-bindings = on\n\n  # 禁用Java默认序列化功能\n  allow-java-serialization = off\n\n  serializers {\n    kryo = \"com.twitter.chill.akka.AkkaSerializer\"\n  }\n\n  serialization-bindings {\n    # 指定所有实现了`java.io.Serializable`接口的类都使用 kryo 序列化\n    \"java.io.Serializable\" = kryo\n  }\n}","title":"Kryo"},{"location":"/data/data.2.html","text":"","title":"Protobuf"},{"location":"/data/data.2.html#protobuf","text":"","title":"Protobuf"},{"location":"/data/data.z.html","text":"","title":"小结"},{"location":"/data/data.z.html#小结","text":"","title":"小结"},{"location":"/test/index.html","text":"","title":"测试"},{"location":"/test/index.html#测试","text":"测试 Scalatest 安装 ScalaTest 第一个测试用例 使用 Matchers OptionValues ScalaFutures Mock 测试异步代码 端到端测试Route Akka HTTP akka-http-testkit OrgRouteTest 总结 小结","title":"测试"},{"location":"/test/test.0.html","text":"","title":"测试"},{"location":"/test/test.0.html#测试","text":"","title":"测试"},{"location":"/test/test.1.html","text":"","title":"Scalatest"},{"location":"/test/test.1.html#scalatest","text":"ScalaTest通过简单、清晰的测试和可执行的规范来提高团队的生产力，同时改进代码和沟通效率。\nScalaTest是Scala生态系统中最灵活、最流行的测试工具。支持测试：Scala、Scala.js（Javascript）和Java代码。可与JUnit、TestNG、Ant、Maven、sbt、ScalaCheck、JMock、EasyMock、Mockito、ScalaMock、Selenium、Eclipse、Netbeans、Intellij、VSCode等工具集成使用。ScalaTest可使Scala、Scala.js或者Java项目的测试更容易，拥有更高的生产力水平。\n为了最大化生产力，ScalaTest内建扩展点并支持多种测试方式。我们可以选择最适合我们团队经验和文化的测试风格。有以下风格可供选择：\nFunSuite：来自xUnit。 FlatSpec：另一个来自xUnit。 FunSpec：来自Ruby’s RSpec的BDD测试风格。 WordSpec：来自specs、specs2，适合训练有素的团队来定义严格的测试规范。也是Akka、Playframework等推荐的风格。 FreeSpec：适合有经验的团队。 PropSpec：适合追求完美的团队，需要前置测试条件定义。 FeatureSpec：主要用于验收测试。 RefSpec（JVM only）：需要定义一个特殊的测试函数，通过测试函数字面量来代码测试功能。","title":"Scalatest"},{"location":"/test/test.1.html#安装-scalatest","text":"ScalaTest的安装、使用很简单，可以直接在命令行使用，如：\n$ scalac -cp scalatest-app_2.12-3.0.5.jar ExampleSpec.scala\n也可以和sbt集成使用。对sbt不了解的读者可以先看：http://www.yangbajing.me/scala-web-development/env.1.html 来快速的学习sbt的使用方法。\n在sbt中添加ScalaTest支持非常简单，在构建配置文件（一般是build.sbt）中添加库依赖即可。\nlibraryDependencies += \"org.scalatest\" %% \"scalatest\" % \"3.0.5\" % \"test\"\n之后重启sbt或在sbt命令行控制台里输入：reload以使其生效。","title":"安装 ScalaTest"},{"location":"/test/test.1.html#第一个测试用例","text":"import scala.collection.mutable\nimport org.scalatest._\n\nclass FirstTest extends WordSpec with Matchers {\n  \"A Stack\" should {\n    \"pop values in last-in-first-out order\" in {\n      val stack = mutable.Stack.empty[Int]\n      stack.push(1)\n      stack.push(2)\n      stack.pop() shouldBe 2\n      stack.pop() shouldBe 1\n    }\n    \n    \"throw NoSuchElementException if an empty stack is popped\" in {\n      val emptyStack = mutable.Stack.empty[Int]\n      assertThrows[NoSuchElementException] {\n        emptyStack.pop()\n      }\n    }\n  }\n}\n运行测试有两种方式：\n使用test命令运行所有测试 使用testOnly命令运行单个测试。\n在sbt中输入testOnly firstFirstTest运行刚写好的第一个测试，结果如下：\n[IJ]scalatest > testOnly first.FirstTest\n[info] Compiling 1 Scala source to /opt/workspace/scala-applications/scalatest/target/scala-2.12/test-classes ...\n[info] Done compiling.\n[info] FirstTest:\n[info] A Stack\n[info] - should pop values in last-in-first-out order\n[info] - should throw NoSuchElementException if an empty stack is popped\n[info] Run completed in 344 milliseconds.\n[info] Total number of tests run: 2\n[info] Suites: completed 1, aborted 0\n[info] Tests: succeeded 2, failed 0, canceled 0, ignored 0, pending 0\n[info] All tests passed.\n[success] Total time: 2 s, completed 2018-8-2 18:29:14","title":"第一个测试用例"},{"location":"/test/test.1.html#使用-matchers","text":"除了默认的断言函数，如：assert、assertResult、assertThrows等，ScalaTest还提供了更好用的 Matchers。**Matchers** 具有以下特性：\n基于表达式断言的DSL，如：stack.pop() shouldBe 2。更易读，以人类语言的方式来编写测试断言。 丰富的断言类型，支持更直观的断言表达式，如：\"abbccxxx\" should startWith regex (\"a(b*)(c*)\" withGroups (\"bb\", \"cc\"))。\n只需要在测试类混入 Matchers 特质，就可以使用 ScalaTest 提供的强大的 Matchers 特性。","title":"使用 Matchers"},{"location":"/test/test.1.html#optionvalues","text":"OptionValues特质提供了一个隐式转换，将一个 value 方法添加到 Option[T] 类型上。若 Option 是有定义的，则 value 方法将返回值，就和调用 .get 一样；若没有，则抛出 TestFailedException 异常，而不是调用 get 方法时抛出的 NoSuchElementException 异常。同时，ScalaTest会输出更友好的错误显示：**The Option on which value was invoked was not defined.**，而不是输出一大堆的错误异常栈而打乱正常的测试输出。\n使用.value\n[info] FirstTest:\n[info] option\n[info] - should value *** FAILED ***\n[info]   The Option on which value was invoked was not defined. (FirstTest.scala:30)\n[info] Run completed in 418 milliseconds.\n[info] Total number of tests run: 3\n[info] Suites: completed 1, aborted 0\n[info] Tests: succeeded 2, failed 1, canceled 0, ignored 0, pending 0\n[info] *** 1 TEST FAILED ***\n[error] Failed tests:\n[error] \tfirst.FirstTest\n[error] (Test / testOnly) sbt.TestsFailedException: Tests unsuccessful\n使用.get\n[info] FirstTest:\n[info] option\n[info] - should value *** FAILED ***\n[info]   java.util.NoSuchElementException: None.get\n[info]   at scala.None$.get(Option.scala:349)\n[info]   at scala.None$.get(Option.scala:347)\n[info]   at first.FirstTest.$anonfun$new$6(FirstTest.scala:31)\n[info]   at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:12)\n[info]   at org.scalatest.OutcomeOf.outcomeOf(OutcomeOf.scala:85)\n[info]   at org.scalatest.OutcomeOf.outcomeOf$(OutcomeOf.scala:83)\n[info]   at org.scalatest.OutcomeOf$.outcomeOf(OutcomeOf.scala:104)\n[info]   at org.scalatest.Transformer.apply(Transformer.scala:22)\n[info]   at org.scalatest.Transformer.apply(Transformer.scala:20)\n[info]   at org.scalatest.WordSpecLike$$anon$1.apply(WordSpecLike.scala:1078)\n[info]   ...\n[info] Run completed in 211 milliseconds.\n[info] Total number of tests run: 3\n[info] Suites: completed 1, aborted 0\n[info] Tests: succeeded 2, failed 1, canceled 0, ignored 0, pending 0\n[info] *** 1 TEST FAILED ***\n[error] Failed tests:\n[error] \tfirst.FirstTest\n[error] (Test / testOnly) sbt.TestsFailedException: Tests unsuccessful","title":"OptionValues"},{"location":"/test/test.1.html#scalafutures","text":"ScalaTest支持对异步代码进行阻塞测试。提供了隐式方法 futureValue 来从 Future[T] 中阻塞获取结果。\noverride implicit def patienceConfig = PatienceConfig(Span(60, Seconds), Span(50, Millis))\n\n  \"future\" should {\n    \"await result === 3\" in {\n      import scala.concurrent.ExecutionContext.Implicits.global\n      val f = Future{\n        Thread.sleep(1000)\n        3\n      }\n      val result = f.futureValue\n      result shouldBe 3\n    }\n  }\n上面代码的运行效果如下：\n[info] FirstTest:\n[info] future\n[info] - should await result === 3\n[info] Run completed in 1 second, 169 milliseconds.\n[info] Total number of tests run: 1\n[info] Suites: completed 1, aborted 0\n[info] Tests: succeeded 1, failed 0, canceled 0, ignored 0, pending 0\n[info] All tests passed.","title":"ScalaFutures"},{"location":"/test/test.1.html#mock","text":"ScalaTest为以下4种Mock提供了原生的支持：\nScalaMock EasyMock JMock Mockito\n这里先简单介绍下 ScalaMock。\nScalaMock是由 Paul Butcher 编写的一个原生的开源Scala Mocking框架，允许模拟对象和函数。ScalaMock支持3种不同的模拟风格：\n函数模拟（Function mocks） 代理（动态）模拟（Proxy (dynamic) mocks） 生成类型安全模拟（Generated (type-safe) mocks）\n函数模拟\n\"scalamock\" should {\n    \"function mock\" in {\n      val m = mockFunction[Int, String]\n      m expects 42 returning \"Forty two\"\n      m(42) shouldBe \"Forty two\"\n    }\n  }\n这里我们模拟了一个函数 m，它接受一个Int参数并返回一个字符串值。这里看到，我们并没有实际定义这样一个函数，而是使用 m expects 42 returning \"Forty two\" 声明了这个模拟期待一个输入值：42，并返回结果字符串：Forty row。执行这个测试，运行效果如下：\n[info] FirstTest:\n[info] scalamock\n[info] - should function mock\n[info] Run completed in 211 milliseconds.\n[info] Total number of tests run: 1\n[info] Suites: completed 1, aborted 0\n[info] Tests: succeeded 1, failed 0, canceled 0, ignored 0, pending 0\n[info] All tests passed.","title":"Mock"},{"location":"/test/test.2.html","text":"","title":"测试异步代码"},{"location":"/test/test.2.html#测试异步代码","text":"","title":"测试异步代码"},{"location":"/test/test.3.html","text":"","title":"端到端测试Route"},{"location":"/test/test.3.html#端到端测试route","text":"","title":"端到端测试Route"},{"location":"/test/test.3.html#akka-http","text":"这里我们将使用 Akka HTTP来开发一个很简单的业务应用：组织管理。它只有一个数据模型，**Org**。组织支持树型结构，所有每个 org 里面都可以有一个可选 parent 属性来指向父组织，若没有则代表此 org 是个一级组织。Org 的数据模型如下：\ncase class Org(\n  id Int,  // PK\n  code Option[String], // 组织编码，可选值。Unique index\n  name String,\n  contact: ObjectNode, // Json类型，使用Jackson\n  parent Option[String], // 父组织\n  parents List[String], // 父组织全路径\n  status: Int,\n  createdAt OffsetDateTime,\n  updatedAt Option[OffsetDateTime]\n)\n业务流程上，对一个 Org 模型的操作我们设计如下的简单流程：\nOrgRoute -> OrgService -> OrgRepo\nOrgRoute 是一个使用 Akka HTTP Routing DSL 来定义实现的路由（从MVC架构术语来说，就是控制器（Controller））。从这个简单的示例来说，它拥有如下接口：\ncreateRoute：创建 Org getRoute：根据id或code获取 Org pageRoute：分页查询 updateRoute：更新 Org removeRoute：根据id删除 Org\n现在，我们已经设计好了我们需要的5个接口（名字），接下来需要定义具体的接口和实现。这里，我们先从测试开始。","title":"Akka HTTP"},{"location":"/test/test.3.html#akka-http-testkit","text":"Akka HTTP 提供了一个测试套件来简化对 Akka HTTP 和 Akka HTTP Routing DSL的测试，我们需要在 sbt 配置里加上对应的库依赖：\nlibraryDependencies += \"com.typesafe.akka\" %% \"akka-http-testkit\" % \"2.5.14\" % Test\n定义一个 Akka HTTP Routing DSL 的测试类，需要混入 ScalatestRouteTest 特质，它提供了对 Route DSL 的一系列测试辅助函数来支持Scalatest。","title":"akka-http-testkit"},{"location":"/test/test.3.html#orgroutetest","text":"现在，我们从 OrgRouteTest 开始，通过 红-绿-红-绿这样的测试循环来验证并一步一步实现对 Org 的各项接口功能。\n首先，让我们来看看这个 OrgRouteTest 类：\nclass OrgRouteTest\n    extends WordSpec\n    with BeforeAndAfterAll\n    with ScalatestRouteTest\n    with Matchers\n    with OptionValues\n    with ScalaFutures {\n\n  private val schema = new Schema()\n  private var orgIds: Set[Int] = Set()\n  private val orgService = new OrgService(schema)\n  private val route: Route = new OrgRoute(orgService).route\n\n  \"OrgRoute\" should {\n    import helloscala.http.JacksonSupport._\n\n    var org: Org = null\n\n    \"create\" in {\n      val req = OrgCreateReq(Some(\"000001\"), \"测试组织\", None, None)\n      Post(\"/org/item\", req) ~> route ~> check {\n        status shouldBe StatusCodes.Created\n        org = responseAs[Org]\n        orgIds += org.id\n        org.id should be > 0\n        org.parent shouldBe None\n        org.updatedAt shouldBe None\n      }\n    }\n\n    \"get\" in {\n      pending\n    }\n\n    \"pageRoute\" in {\n      pending\n    }\n\n    \"updateRoute\" in {\n      pending\n    }\n\n    \"remoteRoute\" in {\n      pending\n    }\n  }\n\n  private def cleanup(): Unit = try {\n    orgService.removeByIds(orgIds).futureValue\n  } catch {\n    case NonFatal(e) => e.printStackTrace()\n  }\n\n  override def afterAll() {\n    cleanup()\n    schema.db.close()\n    super.afterAll()\n  }\n\n}\n完整代码请见：https://github.com/yangbajing/scala-web-development/blob/master/scala-web/test/src/test/scala/scalaweb/test/route/OrgRouteTest.scala。\n这里的**OrgRouteTest**测试类继续了多个接口：\nWordSpec：使用了**Word**风格的测试，必需要混入这样的一个测试规范接口。类似的有：**FutureSpec**、**FlatSpec**等 BeforeAndAfterAll：提供了所有测试用例执行前或完成后的钩子函数 ScalatestRouteTest：Akka HTTP Routing 测试的辅助函数 Matchers：用户友好的断言DSL OptionValues：Option类型的辅助函数 ScalaFutures：Future类型的辅助函数\n这里可以看到定义了5个测试样例，其中 create 测试样例已经实现，其它4个暂未实现，使用 pending 函数占位。\n在测试开始，定义了3个变量：\nschema：数据库连接管理 orgIds：测试生成的组织ID列表，待测试完成后可用来进行数据清除 route：要测试的路由","title":"OrgRouteTest"},{"location":"/test/test.3.html#routing-test-dsl","text":"在 create 测试用例中，使用 ~> 函数连接了 Post（请求）、route（路由）、check（检测函数）三个部分。Post定义了我们要发起的测试请求，通过 ~> 符号（函数）连接（发送）到route（路由），然后再用 ~> 将响应连接到 check 函数来做检测（断言）。Post实际是调用了 RequestBuilder，RequestBuilder有多个重载函数，这里使用了需要一个ToEntityMarshaller[T]隐式转换的函数，它可以将我们提交的OrgCreateReq请求（case class）转换成合适的HTTP数据并设置匹配的Content-Type请求头：\ndef apply[T](uri: String, content: T)(implicit m: ToEntityMarshaller[T], ec: ExecutionContext): HttpRequest =\n      apply(uri, Some(content))\n我们使用import helloscala.http.JacksonSupport._来导入Akka HTTP的JSON支持来将请求转换成application/json类型的HTTP请求数据发送到route。*Akka HTTP JSON支持见：JSON*\ncheck\nroute响应的结果将通过 check 函数来进行测试断言，通过ScalatestRouteTest提供了多个辅助函数来完成测试，而对Akka HTTP routing的各类处理细节被隐藏在了check函数的调用内部。常用的辅助函数有：\nstatus：获取响应的HTTP状态码 response：获取响应数据 responseAs[T: FromResponseUnmarshaller]：将响应数据（body）转换成T类型 entityAs[T: FromEntityUnmarshaller]：类似responseAs，但是将HttpEntity转换成T类型 contentType：获取响应的Conent-Type `mediaType：获取响应的MediaType headers：获取响应的所有header头 header[T >: Null <: HttpHeader: ClassTag]：查找指定类型的响应header头，返回结果为Option[T]","title":"routing test dsl"},{"location":"/test/test.3.html#run-test","text":"在sbt console中执行命令运行测试：test/testOnly scalaweb.test.route.OrgRouteTest，结果如下：\n01:04:39.075 INFO com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Starting...\n01:04:39.238 INFO com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Start completed.\n01:04:40.439 DEBUG slick.jdbc.JdbcBackend.statement - Preparing insert statement (returning: id,code,name,contact,parent,parents,status,created_at,updated_at): insert into \"t_org\" (\"code\",\"name\",\"contact\",\"parent\",\"parents\",\"status\",\"created_at\",\"updated_at\")  values (?,?,?,?,?,?,?,?)\n01:04:40.468 DEBUG slick.jdbc.JdbcBackend.benchmark - Execution of prepared update took 4ms\n01:04:41.410 DEBUG slick.jdbc.JdbcBackend.statement - Preparing statement: delete from \"t_org\" where \"t_org\".\"id\" in (5)\n01:04:41.411 DEBUG slick.jdbc.JdbcBackend.benchmark - Execution of prepared update took 499µs\n01:04:41.443 INFO com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Shutdown initiated...\n01:04:41.448 INFO com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Shutdown completed.\n[info] OrgRouteTest:\n[info] OrgRoute\n[info] - should create\n[info] - should get (pending)\n[info] - should pageRoute (pending)\n[info] - should updateRoute (pending)\n[info] - should remoteRoute (pending)\n[info] ScalaTest\n[info] Run completed in 3 seconds, 382 milliseconds.\n[info] Total number of tests run: 1\n[info] Suites: completed 1, aborted 0\n[info] Tests: succeeded 1, failed 0, canceled 0, ignored 0, pending 4\n[info] All tests passed.\n[info] Passed: Total 1, Failed 0, Errors 0, Passed 1, Pending 4\n[success] Total time: 5 s, completed 2018-8-22 1:04:41\n可以看到，这里执行通过了一个测试用例should create，有4个测试用例为**pending**（代表还未实现）。","title":"run test"},{"location":"/test/test.3.html#总结","text":"使用 akka-http-testkit 可以在不启动Server的情况下对定义的route进行测试，可以显著的提高测试效率。","title":"总结"},{"location":"/test/test.z.html","text":"","title":"小结"},{"location":"/test/test.z.html#小结","text":"","title":"小结"},{"location":"/oauth/index.html","text":"","title":"实战：实现OAuth 2服务"},{"location":"/oauth/index.html#实战-实现oauth-2服务","text":"实战：OAuth 2 服务 OAuth 2是如何工作的 为什么是JWT OAuth 2简介 OAuth 2 模式 OAuth 2接口设计 OAuth 2 API接口 OAuth 2服务实现 小结","title":"实战：实现OAuth 2服务"},{"location":"/oauth/oauth.0.html","text":"","title":"实战：OAuth 2 服务"},{"location":"/oauth/oauth.0.html#实战-oauth-2-服务","text":"这章进行一个稍微复杂一点的实战项目：实现 OAuth 2 服务。","title":"实战：OAuth 2 服务"},{"location":"/oauth/oauth.0.html#oauth-2是如何工作的","text":"OAuth 2 在整个流程中有四种角色:\n资源拥有者(Resource Owner) - 这里是Tom 资源服务器(Resource Server) - 这里是Facebook 授权服务器(Authorization Server) - 这里当然还是Facebook，因为Facebook有相关数据 客户端(Client) - 这里是某App\n当Tom试图登录Facebook，某App将他重定向到Facebook的授权服务器，当Tom登录成功，并且许可自己的Email和个人信息被某App获取。这两个资源被定义成一个Scope（权限范围），一旦准许，某App的开发者就可以申请访问权限范围中定义的这两个资源。\n+--------+                               +---------------+\n|        |--(A)- Authorization Request ->|   Resource    |\n|        |                               |     Owner     |\n|        |<-(B)-- Authorization Grant ---|               |\n|        |                               +---------------+\n|        |\n|        |                               +---------------+\n|        |--(C)-- Authorization Grant -->| Authorization |\n| Client |                               |     Server    |\n|        |<-(D)----- Access Token -------|               |\n|        |                               +---------------+\n|        |\n|        |                               +---------------+\n|        |--(E)----- Access Token ------>|    Resource   |\n|        |                               |     Server    |\n|        |<-(F)--- Protected Resource ---|               |\n+--------+                               +---------------+","title":"OAuth 2是如何工作的"},{"location":"/oauth/oauth.0.html#为什么是jwt","text":"OAuth 2并不关心去哪找Access Token和把它存在什么地方的，生成随机字符串并保存Token相关的数据到这些字符串中保存好。通过一个令牌端点，其他服务可能会关心这个Token是否有效，它可以通过哪些权限。这就是用户信息URL方法，授权服务器为了获取用户信息转换为资源服务器。\n当我们谈及微服务时，我们需要找一个Token存储的方式，来保证授权服务器可以被水平扩展，尽管这是一个很复杂的任务。所有访问微服务资源的请求都在Http Header中携带Token，被访问的服务接下来再去请求授权服务器验证Token的有效性，目前这种方式，我们需要两次或者更多次的请求，但这是为了安全性也没什么其他办法。但扩展Token存储会很大影响我们系统的可扩展性，这是我们引入JWT（读jot）的原因。\n+-----------+                                     +-------------+\n|           |       1-Request Authorization       |             |\n|           |------------------------------------>|             |\n|           |     grant_type&username&password    |             |--+\n|           |                                     |Authorization|  | 2-Gen\n|  Client   |                                     |Service      |  |   JWT\n|           |       3-Response Authorization      |             |<-+\n|           |<------------------------------------| Private Key |\n|           |    access_token / refresh_token     |             |\n|           |    token_type / expire_in / jti     |             |\n+-----------+                                     +-------------+","title":"为什么是JWT"},{"location":"/oauth/oauth.1.html","text":"","title":"OAuth 2简介"},{"location":"/oauth/oauth.1.html#oauth-2简介","text":"OAuth 2 是OAuth协议的延续版本，但不向后兼容OAuth 1.0即完全废止了OAuth 1.0。 OAuth 2关注客户端开发者的简易性。 要么通过组织在资源拥有者和HTTP服务商之间的被批准的交互动作代表用户，要么允许第三方应用代表用户获得访问的权限。 同时为Web应用，桌面应用和手机，和起居室设备提供专门的认证流程。2012年10月，OAuth 2协议正式发布为 RFC 6749。","title":"OAuth 2简介"},{"location":"/oauth/oauth.1.html#oauth-2-模式","text":"Web ServerFlow是把OAuth 1.0的三个步骤缩略为两个步骤，首先这个是适合有server的第三方使用的。\n客户端通过HTTP请求Authorize 服务端接收到Authorize请求，返回用户登陆页面 用户在登陆页面登陆 登录成功后，服务端将浏览器定位到 redirect_uri，并同时传递Authorization Code 客户端使用HTTPS发送Authorization Code 服务器端收到 access_token 请求，验证Authorization Code——生成 access_token，refresh_token和expires_in（过期时间）——access_token和refresh_token和过期时间入库 返回access_token和refresh_token，expires_in（过期时间） 用户使用HTTPS协议，发送access_token及相应参数请求开放平台接口\nOAuth 2除了支持浏览器端认证外，还支持APP、C/S客户端认证。","title":"OAuth 2 模式"},{"location":"/oauth/oauth.2.html","text":"","title":"OAuth 2接口设计"},{"location":"/oauth/oauth.2.html#oauth-2接口设计","text":"根据上一节的介绍，我们这里只实现部分 OAuth 2的功能，完整的OAuth 2功能实现留待作者自行实现。\n首先我们来实现 OAuth 2 的接口，OAuth 2为基于HTTP的协议，首先来设计并实现 OAuth 2 的API接口。","title":"OAuth 2接口设计"},{"location":"/oauth/oauth.2.html#oauth-2-api接口","text":"实现一个OAuth 2服务端功能，需要定义如下几个接口：\noverride def route: Route = pathPrefix(\"oauth2\") {\n    authorizeSigninHTML ~\n      signinRoute ~\n      tokenGetRoute ~\n      validationRoute\n  }\n/oauth2/authorize authorizeSigninHTML：返回OAuth 2登录页面 /oauth2/signin signinRoute：OAuth 2用户登录请求接口 /oauth2/token tokenGetRoute：通过code获取access_token接口 /oauth2/validation validationRoute：校验access_token是否有效","title":"OAuth 2 API接口"},{"location":"/oauth/oauth.2.html#oauth-2登录页面","text":"def authorizeSigninHTML: Route = pathGet(\"authorize\") {\n    getFromResource(\"html/oauth2/authorize.html\")\n  }\ngetFromResource通过从Java类查找路径（classpath）中找到指定的文件并返回给客户端，同时会通过文件后缀名来设置响应的Content-Type。","title":"OAuth 2登录页面"},{"location":"/oauth/oauth.2.html#oauth-2用户登录请求","text":"def signinRoute: Route = pathPost(\"signin\") {\n    val pdm = ('account, 'password, 'response_type, 'client_id, 'redirect_uri, 'scope, 'state)\n    formFields(pdm).as(AuthorizeSigninRequest.apply _) { req =>\n      onSuccess(oauth2Service.authorizeSignin(req)) { redirectUri =>\n        complete(HttpResponse(StatusCodes.Found, headers = List(Location(redirectUri))))\n      }\n    }\n  }\n用户登录需要使用application/x-www-form-urlencoded请求类型发送登录信息，登录成功的话将响应HTTP状态码302，并重定向到登录成功后要访问的接入应用页面。\n这里需要使用传统的\n…. 方式来提交登录请求，这样响应里的 ‘Location’ 重定向才能生效。","title":"OAuth 2用户登录请求"},{"location":"/oauth/oauth.2.html#通过code获取access-token","text":"def tokenGetRoute: Route = (path(\"token\") | path(\"access_token\") & get) {\n    val tokenRequestPDM = ('grant_type, 'client_id, 'client_key, 'code, 'redirect_uri, 'echostr)\n    parameters(tokenRequestPDM).as(AuthorizeTokenRequest.apply _) { req =>\n      extractExecutionContext { implicit ec =>\n        val future = req.grantType match {\n          case OAuthConstants.AUTHORIZATION_CODE => oauth2Service.accessTokenForAuthorization(req)\n          case OAuthConstants.CLIENT_CREDENTIALS => oauth2Service.accessTokenForClient(req)\n        }\n        futureComplete(future)\n      }\n    }\n  }\n在用户通过OAuth 2登录成功后，服务端会在redirect_uri回调地址带上code参数来访问应用的一个登录成功回调地址，应用在获取到code参数后请通过调用此接口来获取访问令牌：access_token。这里需要传6个参数：\ngrant_type：授权类型，这里我们实现了对 authorization_code 类型的支持。 client_id：应用客户端ID。 client_key：应用客户端密钥。 code：获取到的code redirect_uri：重定向页面，与之前通过OAuth 2登录页面成功后重定向的地址相同。 echostr：随机字符串","title":"通过code获取access_token"},{"location":"/oauth/oauth.2.html#校验-access-token-是否有效","text":"def validationRoute: Route = pathGet(\"validation\") {\n    optionalAccessToken {\n      case Some(accessToken) =>\n        onSuccess(oauth2Service.validationAccessToken(accessToken)) {\n          case true => complete(StatusCodes.OK)\n          case _    => complete(StatusCodes.Unauthorized)\n        }\n      case _ => reject(OAuthRejection(\"参数'access_token'缺失\"))\n    }\n  }\n此接口用于校验 access_token 是否有效，若校验有效的话将返回预计到期时间（epoch seconds）。\n这里我们使用了一个自定义指令 optionalAccessToken 来从请求中获取 access_token，代码如下：\ndef optionalAccessToken: Directive1[Option[String]] = extract { ctx =>\n    ctx.request.header[Authorization].flatMap { header =>\n      header.credentials match {\n        case OAuth2BearerToken(accessToken) => Some(accessToken)\n        case _                              => None\n      }\n    } orElse\n      ctx.request.uri.query().get(\"access_token\") orElse\n      ctx.request.headers.find(_.lowercaseName() == \"access_token\").map(_.value())\n  }\n在OAuth 2官方协议里，access_token可以通过多种方式进行传输：\nAuthorization头设置 bearer 方式 通过form表单方式 通过url参数\n这里，为了HTTP请求方法（method）的统一，实现为分别从Authorization header头、uri请求参数、命名为access_token的 header头三种形式依次获取。","title":"校验 access_token 是否有效"},{"location":"/oauth/oauth.3.html","text":"","title":"OAuth 2服务实现"},{"location":"/oauth/oauth.3.html#oauth-2服务实现","text":"TODO","title":"OAuth 2服务实现"},{"location":"/oauth/oauth.z.html","text":"","title":"小结"},{"location":"/oauth/oauth.z.html#小结","text":"","title":"小结"},{"location":"/database/index.html","text":"","title":"访问数据库"},{"location":"/database/index.html#访问数据库","text":"访问数据库 使用 JDBC 访问 PostgreSQL PostgreSQL 访问数据库 使用 Slick 访问数据库 访问 Cassandra 数据库 Cassandra 数据模型 安装、配置 Cassandra Alpakka Cassandra Connector 访问 Redis 安装 添加库依赖 访问 Elasticsearch 安装 添加库依赖 小结","title":"访问数据库"},{"location":"/database/database.0.html","text":"","title":"访问数据库"},{"location":"/database/database.0.html#访问数据库","text":"本章将介绍在 Akka HTTP 里怎样访问数据库，我们将使用 JDBC 来操作关系数据库，同时也将介绍怎样访问 NoSQL 数据库。\n本章代码见：codes/akka-http-foundation","title":"访问数据库"},{"location":"/database/database.1.html","text":"","title":"使用 JDBC 访问 PostgreSQL"},{"location":"/database/database.1.html#使用-jdbc-访问-postgresql","text":"在 Scala 中，Java 的数据库访问方式都可以使用，比如：JDBC、JPA、MyBatis、Hibernate等。除此之外，也有些专为 Scala 制作的数据库访问库，如： Slick、ScalikeJDBC、Quill等。但这里，我们介绍在 Scala 中怎样使用 JDBC。","title":"使用 JDBC 访问 PostgreSQL"},{"location":"/database/database.1.html#postgresql","text":"首先，安装 PostgreSQL 数据库。","title":"PostgreSQL"},{"location":"/database/database.1.html#linux","text":"apt-get install postgresql // Debian/Ubuntu\nyum install postgresql // Fedora/CentOS/RHEL","title":"Linux"},{"location":"/database/database.1.html#mac","text":"brew install postgresql","title":"Mac"},{"location":"/database/database.1.html#windows","text":"到 EnterpriseDB 官网下载二进制安装包：[https://www.enterprisedb.com/downloads/postgres-postgresql-downloads#windows](https://www.enterprisedb.com/downloads/postgres-postgresql-downloads#windows)","title":"Windows"},{"location":"/database/database.1.html#配置网络","text":"Linux下，PostgreSQL默认是不允许通过远程网络访问的。我们需要修改下它的默认配置。\nUbunux：/etc/postgresql/9.6/main 目录 CentOS：/var/lib/pgsql/data 目录\n编辑 postgresql.conf 文件，去掉 listen_address 的注释，并修改为：\nlisten_address = '*'\n同时也去掉 password_encryption 的注释。\n编辑 pg_hba.conf 文件，添加：host all all 0.0.0.0/0 md ，设置允许所有网络访问并使用 md5 形式的密码登录机制。\n（注意：修改PostgreSQL的配置文件后需要重启数据库以使其生效）","title":"配置网络"},{"location":"/database/database.1.html#创建账号及初使化库-表","text":"","title":"创建账号及初使化库、表"},{"location":"/database/database.1.html#创建账号-数据库","text":"sudo su - postgres\npsql\npostgres=# create user yangbajing nosuperuser encrypted password 'yangbajing';\npostgres=# create database akkahttp owner=yangbajing template=template0 encoding='UTF-8' lc_collate='zh_CN.UTF-8' lc_ctype='zh_CN.UTF-8';","title":"创建账号、数据库"},{"location":"/database/database.1.html#初始化表-数据","text":"CREATE TABLE author(\n  id bigserial,\n  name VARCHAR(255) NOT NULL,\n  age int,\n  remark TEXT,\n  PRIMARY KEY (id)\n);\n\nCREATE TABLE book(\n  isbn VARCHAR(64),\n  author bigint NOT NULL,\n  title VARCHAR(255) NOT NULL,\n  description VARCHAR(1024),\n  amount DECIMAL NOT NULL,\n  PRIMARY KEY (isbn)\n);","title":"初始化表、数据"},{"location":"/database/database.1.html#访问数据库","text":"","title":"访问数据库"},{"location":"/database/database.1.html#命令行","text":"psql -h localhost -d hldev -U hldev","title":"命令行"},{"location":"/database/database.1.html#代码访问","text":"首先，我们定义两个数据库实体对象：Author 和 Book：\ncase class Author(id: Long, name: String, age: Option[Int], remark: Option[String])\ncase class Book(isbn: String, author: Long, title: String, amount: BigDecimal, description: Option[String])\n接下来在 AuthorRepository 中进行数据库操作，现在先把什么 Service，Controller等放一边，我们使用 scalatest 来测试下我们的数 据库访问代码。\nclass AuthorRepositoryTest extends MeSpec with JDBCSpec {\n\n  \"AuthorRepositoryTest\" should {\n\n    val accountRepository = new AuthorRepository(dataSource)\n\n    \"create\" in {\n      val account = Author(0, \"羊八井\", Some(31), None)\n      val result = accountRepository.create(account)\n      result.id should be > 0L\n    }\n\n    \"update\" in {\n      val author = Author(1, \"羊八井\", Some(32), None)\n      val result = accountRepository.update(author)\n      result.id shouldBe author.id\n      result.name shouldBe author.name\n      result.age shouldBe author.age\n    }\n\n    \"list\" in {\n      val results = accountRepository.list()\n      results should not be empty\n      println(s\"results size: ${results.size}\")\n    }\n\n  }\n\n}\n先不管 MeSpec 和 JDBCSpec 两个 trait，你可以先试试这个测试（前题是你已经设置好数据库环境）。\n> testOnly akkahttp.foundation.data.repository.AuthorRepositoryTest\n若一切正常，你会看到测试正确通过。AuthorRepositoryTert 脚本中一共执行了3个测试，其中 should list 测试中打印了一个测试输出，从数据库中 获取到8条记录。下面，让我们来看看 AuthorRepository ，我们怎么在 Scala 中使用 JDBC 来访问数据库的。\nclass AuthorRepository(dataSource: DataSource) {\n  val jdbcTemplate = JdbcTemplate(dataSource)\n\n  def update(author: Author): Author = {\n    require(author.id > 0L, \"id 必有大于 0\")\n\n    val (names, args) = AuthorRepository.generateArgs(author)\n    val updateSet = JdbcTemplate.sqlUpdateSets(names)\n    val sql = s\"UPDATE author SET $updateSet WHERE id = ? RETURNING *\"\n    args.append(author.id.asInstanceOf[Object])\n\n    val (results, _) = jdbcTemplate.queryMany(sql, args)\n    if (results.isEmpty) {\n      throw new SQLException(s\"账号：${author.id} 不存在\")\n    } else {\n      AuthorRepository.generateResult(results.head)\n    }\n  }\n\n  def create(author: Author): Author = {\n    require(author.id <= 1L, \"id 不能存在\")\n\n    val (names, args) = AuthorRepository.generateArgs(author)\n    val sql =\n      s\"\"\"INSERT INTO author(${JdbcTemplate.sqlNames(names)})\n         |  VALUES(${JdbcTemplate.sqlArgs(args)}) RETURNING id\"\"\".stripMargin\n\n    val (results, labels) = jdbcTemplate.queryMany(sql, args)\n\n    val id = results.head.apply(labels.head.label).asInstanceOf[Long]\n    author.copy(id = id)\n  }\n\n  def list(): Vector[Author] = {\n    val (results, _) = jdbcTemplate.queryMany(\"SELECT id, name, age, remark FROM author ORDER BY id DESC\")\n    results.map(AuthorRepository.generateResult)\n  }\n\n}\n这里我们没有使用 Ioc 等方式来管理组件件的依赖，我们在类的构造代码区里实例华一个 jdbcTemplate。 在 update 方法的开头，我们效验 Author id 是否有效。 主意这里的 SQL 语句，在普通的 update 语句之上添加了 RETURNING * 语句。这里 PostgreSQL 数据库的一个扩展特性，它将返回语句影 响记录的所有字段。可以通过这个特性很方便的在更新语句之后获取到最新的数据。 generateResult 函数，把返回的键值对形式的数据转换映射成一个 Author 对象 这里使用 RETURNING id 返回数据库序列自动生成的 Author id\n在 AuthorRepository 的伴生对象里，有两个简单的帮助函数，generateResult 和 generateArgs ，分别将通过JDBC的ResultSet获取的记录映射 成一个 Author 对象和将 author 对象转换成可用于 INSERT、UPDATE语句字段序列部分及获取有效参数的一个序列。这段话说起来有点拗口，直接来 看看 generateArgs 的代码：\ndef generateResult(result: Map[String, AnyRef]): Author =\n  Author(\n    result(\"id\").asInstanceOf[Long],\n    result(\"name\").asInstanceOf[String],\n    result.get(\"age\").map(_.asInstanceOf[Int]),\n    result.get(\"remark\").map(_.asInstanceOf[String]))\n\n/**\n * 获取有效的数据库查询字段名列表和参数值列表\n *\n * @param author Author实例\n * @return\n */\ndef generateArgs(author: Author): (mutable.Buffer[String], mutable.Buffer[Object]) = {\n  val names = mutable.Buffer.empty[String]\n  val args = mutable.Buffer.empty[Object]\n\n  names.append(\"name\")\n  args += author.name\n\n  author.age.foreach { value =>\n    names.append(\"age\")\n    args += Integer.valueOf(value)\n  }\n\n  author.remark.foreach { remark =>\n    names.append(\"remark\")\n    args += remark\n  }\n  (names, args)\n}\n我们有一个 Author 对象的实例：Author(0, “羊八井”, Some(31), None)。在调用 generateArgs 函数后，将获得以下转出结果：\n([\"name\", \"age\"], [\"羊八井\", 32])\n我们获得了一个 Tuple（元组），第一个值是字段名的序列，第二个值是数据（参数）序列。有了这两个序列后，再使用 JdbcTemplate.sqlNames 和 JdbcTemplate.sqlArgs 来简化我们 SQL 语句的拼装。\n// [name, age] => \"name\" = ?, \"age\" = ?\n  def sqlUpdateSets(names: Seq[String]): String = names.map(name => s\"\"\"\"$name\" = ?\"\"\").mkString(\", \")\n\n  // [name, age] => \"name\", \"age\"\n  def sqlNames(names: Seq[String]): String = names.mkString(\"\\\"\", \"\\\", \\\"\", \"\\\"\")\n\n  // [value1, value2] => ?, ?\n  def sqlArgs(args: Seq[_]): String = args.map(_ => \"?\").mkString(\", \")\n经过这些简单的函数步骤，我们就可以很方便的拼接出想要的SQL语句了。\n// INSERT INTO author(name, age) VALUES(?, ?) RETURNING id\nval sql = \"\"\"INSERT INTO author(${JdbcTemplate.sqlNames(names)}) VALUES(${JdbcTemplate.sqlArgs(args)}) RETURNING id\"\"\"\nJDBC是Java里标准的SQL访问方式，Scala 作为一门 JVM 语言是天然支持的。而 PostgreSQL 是开源界里优秀的关系型数据库，也是功能做为丰富的。这里我们 知道了在 Scala 里面怎样使用 SQL 来访问关系型数据库，下一节将介绍怎样访问 Cassandra 这一强大的 NoSQL 数据库。","title":"代码访问"},{"location":"/database/database.2.html","text":"","title":"使用 Slick 访问数据库"},{"location":"/database/database.2.html#使用-slick-访问数据库","text":"详细见 《Slick 开发》 https://www.yangbajing.me/slick-development/","title":"使用 Slick 访问数据库"},{"location":"/database/database.3.html","text":"","title":"访问 Cassandra 数据库"},{"location":"/database/database.3.html#访问-cassandra-数据库","text":"","title":"访问 Cassandra 数据库"},{"location":"/database/database.3.html#cassandra-数据模型","text":"","title":"Cassandra 数据模型"},{"location":"/database/database.3.html#cassandra-与-传统关系性数据库的区别及特性","text":"No joins：没有关联操作，对于在 SQL 中这类操作你需要先获得主表数据后再通过 id 去关联，或者反范式化设计将关联表数据做为扩展内 容直接存到主表中。 No referential integrity：没有外键约束，没有参照完整性，当然也没有级联操作。需要在应用中小心注意删除或修改关联数据。 Denormalization：非范式化，使用 Cassandra 进行数据建模使用范式化设计是不高效的。 Query-first design：查询先行的设计，使用 Cassandra 建模需要首先、小心设计好查询方式。因为它只有在根据主键搜索时（3.0开始支 持第二索引，但效率不高）才能高效。 Designing for optimal storage：在建模设计时就需要考虑存储优化，使用关系性数据库时一般是不用管数据存储的。但使用 Cassandra 时就需要提前规划，因为 Cassandra 的数据是默认分区的，而分区的形式对性能有着很大的影响。 Sorting is a design decision：设计时需要决定排序方式。在建表时就决定了排序方式，并且只有 Cluster Key 支持排序。\nCassandra 的数据模型可以简单类比为：Map<PartitionKey, SortedMap<ClusterKey, Value>>，也可以简化成：KKV。\nCassandra 有如下主要数据结构：\ncolumn：列，类似于 name/value 对。 row：包含多个列的容器，并使用主键引用。 table：包含多个行的容器。 keyspace：包含多个表的容器。 cluster：集群，包含多个 keyspace 的容器，使用一个或多个节点。","title":"Cassandra 与 传统关系性数据库的区别及特性"},{"location":"/database/database.3.html#安装-配置-cassandra","text":"","title":"安装、配置 Cassandra"},{"location":"/database/database.3.html#下载-安装","text":"wget -c http://archive.apache.org/dist/cassandra/3.9/apache-cassandra-3.9-bin.tar.gz\ntar zxf apache-cassandra-3.9-bin.tar.gz\ncd apache-cassandra-3.9\n./bin/cassandra","title":"下载、安装"},{"location":"/database/database.3.html#初始化数据库-表","text":"./bin/cqlsh\ncqlsh> CREATE KEYSPACE hldev WITH replication = {'class': 'SimpleStrategy', 'replication_factor': '1'};\ncqlsh> use hldev;\ncqlsh:hldev> CREATE TABLE user(\n         ...   id TIMEUUID,\n         ...   email TEXT,\n         ...   name TEXT,\n         ...   created_at TIMESTAMP,\n         ...   salt blob,\n         ...   salt_password blob,\n         ...   PRIMARY KEY (id, email, name)\n         ... );\n这里创建了一个 keyspace，一张表，对于我们的示例足够了。","title":"初始化数据库、表"},{"location":"/database/database.3.html#alpakka-cassandra-connector","text":"这里我们介绍怎样使用 Alpakka 的 Cassandra Connector 来访问 Cassandra。 Alpakka Cassandra是基于 Akka Stream 的一个Connector，它提供了使用 Akka Stream 的编程模型来访问 Cassandra 数据库的功能。","title":"Alpakka Cassandra Connector"},{"location":"/database/database.3.html#添加库依赖","text":"libraryDependencies += \"com.lightbend.akka\" %% \"akka-stream-alpakka-cassandra\" % \"0.7\"","title":"添加库依赖"},{"location":"/database/database.3.html#访问cassandra","text":"继续能过单元测试来看看怎样使用 Alpakka Cassandra Connector 访问 Cassandra 数据库的。\nsbt\n> testOnly akkahttp.foundation.data.repository.UserRepositoryTest\n测试结果如下：\n这里，我们把注意力关注在 UserRepository.scala 上，UserRepositoryTest 单元测试和上一节访问 PostgreSQL 库的测试无本质区 别，但数据库访问代码区别可就大了。\n首先，我们使用了 Alpakka 里提供的 Akka Stream for Cassandra Connector 来访问，并没有直接使用官方提供的 cassandra-driver-core 。\nclass UserRepository(cassandraSession: StandaloneCassandraSession\n                    )(\n                      implicit val materializer: Materializer, ec: ExecutionContext\n                    ) {\n\n  import cassandraSession.session  // (1)\n\n  def deleteById(userId: UUID): Future[Done] = {\n    val stmt = cassandraSession.prepare(\"delete from hldev.user where id = ?\").bind(userId)\n    CassandraSource(stmt).runWith(Sink.ignore)  // (2)\n  }\n\n  def insert(user: User, password: SaltPassword): Future[Done] = {\n    val stmt = cassandraSession\n      .prepare(\"insert into hldev.user(id, email, name, created_at, salt, salt_password) values(?, ?, ?, ?, ?, ?)\")\n      .bind(\n        user.id,\n        user.email,\n        user.email.split('@')(0),\n        user.createdAt,\n        ByteBuffer.wrap(password.salt),\n        ByteBuffer.wrap(password.saltPwd))\n    CassandraSource(stmt).runWith(Sink.ignore)\n  }\n\n  def login(email: String, password: String): Future[Option[(User, Array[Byte], Array[Byte])]] = {\n    val stmt = cassandraSession\n      .prepare(\"select * from hldev.user where email = ? ALLOW FILTERING\")\n      .bind(email)\n    CassandraSource(stmt)\n      .runWith(Sink.headOption) // (3)\n      .map(maybeRow => // (4)\n        maybeRow.map(row =>\n          (UserRepository.mapToUser(row),\n            Utils.byteBufferToArray(row.getBytes(\"salt\")),\n            Utils.byteBufferToArray(row.getBytes(\"salt_password\")))\n        ))\n  }\n\n  def findById(userId: UUID): Future[Option[User]] = {\n    val stmt = cassandraSession\n      .prepare(\"select * from hldev.user where id = ?\")\n      .bind(userId)\n    CassandraSource(stmt)\n      .runWith(Sink.headOption)\n      .map(maybeRow => maybeRow.map(row => UserRepository.mapToUser(row)))\n  }\n\n  def existsByEmail(email: String): Future[Boolean] = {\n    CassandraSource(cassandraSession.prepare(\"select count(1) as COUNT from hldev.user where email = ? ALLOW FILTERING\").bind(email))\n      .runWith(Sink.head)\n      .map(row => row.getLong(\"COUNT\") == 1)\n  }\n}\n(1)：首先需要从 cassandraSession 中导入 com.datastax.driver.core.Session 异常变量，这个是 CassandraSource 需要的 (2)：对于 DELETE 语句，Cassandra 驱动并没向SQL一样返回语句影响的行数这样的返回值，这里在 runWith 函数里使用 Sink.ignore 忽略返回值 (3)：对于 login 这个操作，我们使用 Sink.headOption 获取第一个值。若没有找到任务匹配值则返回 None (4)：转换获取的 ResultSet 为 User 对象\nAlpakka Cassandra Connector 提供了兼容 Akka Stream 的方式来快速访问 Cassandra 数据库，使用响应式的编程。对于 Akka Stream， 可以阅读 Akka Stream Quicktart 快速了解其基本原理 和使用方式。本书介绍的 Akka HTTP 是构建在 Akka Stream 之上的，而 Alpakka Cassansdra Connector可以紧密地和Akka HTTP进行结合， 使我们的应用吏响应式、高效。\n警告 在使用 Cassandra 提供的批量插入功能时，也许需要修改下数据库默认配置。在使用 BatchStatement 进行插入操作时会发现，当数据量稍大以后数据库中并没有加入新的数据。这是因为Cassandra默认对批量操作的数据大小限制得比较低。我们将其修改即可。\n# Log WARN on any batch size exceeding this value. 5kb per batch by default.\n# Caution should be taken on increasing the size of this threshold as it can lead to node instability.\nbatch_size_warn_threshold_in_kb: 1000\n\n# Fail any batch exceeding this value. 50kb (10x warn threshold) by default.\nbatch_size_fail_threshold_in_kb: 2000","title":"访问Cassandra"},{"location":"/database/database.4.html","text":"","title":"访问 Redis"},{"location":"/database/database.4.html#访问-redis","text":"","title":"访问 Redis"},{"location":"/database/database.4.html#安装","text":"wget -c http://download.redis.io/releases/redis-3.2.8.tar.gz\ncd redis-3.2.8\nmake\n# 请设置自己想要的 PREFIX 目录\nmake PREFIX=/home/local/redis install\ncd /home/local/redis/\n./bin/redis-server\n当看到：23894:M 24 Apr 17:22:13.628 * The server is now ready to accept connections on port 6379 类似输出则代码 Redis 服务已正常启动。","title":"安装"},{"location":"/database/database.4.html#添加库依赖","text":"使用 https://github.com/debasishg/scala-redis 库来做为客户端访问 Redis。\nlibraryDependencies += \"net.debasishg\" %% \"redisclient\" % \"3.4\"\n惯例，这里也使用 scalatest 来演示 Redis 的基本使用。\nclass RedisSessionTest extends MeSpec with RedisSpec {\n\n  \"RedisComponentTest\" should {\n    \"KV set\" in {\n      redisSession.withClient(cli => cli.set(\"id\", \"yangbajing\")) shouldBe true\n    }\n\n    \"KV get\" in {\n      redisSession.withClient(cli => cli.get(\"id\")) shouldBe Some(\"yangbajing\")\n    }\n  }\n\n}\n在本书的后面，我们将触及到更多的 Redis 应用。比如将用户会话信息放到 Redis 中。","title":"添加库依赖"},{"location":"/database/database.5.html","text":"","title":"访问 Elasticsearch"},{"location":"/database/database.5.html#访问-elasticsearch","text":"","title":"访问 Elasticsearch"},{"location":"/database/database.5.html#安装","text":"在 https://elastic.co/ 官网下载对应操作系统版本。\ncd elasticsearch-5.3.1\n./bin/elasticsearch\n看到类似输出则代表 Elasticsearch 已正常启动：\n[2017-04-25T11:58:40,412][INFO ][o.e.h.HttpServer         ] [MTz4O40] publish_address {127.0.0.1:9200}, bound_addresses {[::1]:9200}, {127.0.0.1:9200}\n[2017-04-25T11:58:40,413][INFO ][o.e.n.Node               ] [MTz4O40] started\n可以使用 REST 接口来访问 Elasticsearch：\ncurl -XPUT http://localhost:9200/blog/article/1?pretty -d '{\"title\": \"新版本Elasticsearch发布\", \"content\": \"5.3.1今天发布了\", \"tags\": [\"announce\", \"elasticsearch\", \"发布\"] }'\n返回结果如下，可以看到：\"result\": \"created\"，这代表这是一个新建操作，当前版本号为 1。\n{\n  \"_index\" : \"blog\",\n  \"_type\" : \"article\",\n  \"_id\" : \"1\",\n  \"_version\" : 1,\n  \"result\" : \"created\",\n  \"_shards\" : {\n    \"total\" : 2,\n    \"successful\" : 1,\n    \"failed\" : 0\n  },\n  \"created\" : true\n}","title":"安装"},{"location":"/database/database.5.html#添加库依赖","text":"libraryDependencies += \"com.sksamuel.elastic4s\" %% \"elastic4s-tcp\" % \"5.3.1\"","title":"添加库依赖"},{"location":"/database/database.z.html","text":"","title":"小结"},{"location":"/database/database.z.html#小结","text":"TODO","title":"小结"},{"location":"/engineering/index.html","text":"","title":"工程化"},{"location":"/engineering/index.html#工程化","text":"使用Swagger编写API文档 使用Guice管理类依赖 JSR-330","title":"工程化"},{"location":"/engineering/swagger.html","text":"","title":"使用Swagger编写API文档"},{"location":"/engineering/swagger.html#使用swagger编写api文档","text":"TODO","title":"使用Swagger编写API文档"},{"location":"/engineering/guice.html","text":"","title":"使用Guice管理类依赖"},{"location":"/engineering/guice.html#使用guice管理类依赖","text":"当项目规模大了以后，依赖管理是一个很头疼的问题。手工管理众多类的实例化和构造顺序是一个枯燥且容易出错的事情。在Java世界，JSR-330规范（Java依赖注入规范）定义了一套标准的接口来实现此功能。 该规范主要是面向依赖注入使用者，而对注入器实现、配置并未作详细要求。目前 Spring、Guice实现了该规范，JSR-299（Contexts and Dependency Injection for Java EE platform，参考实现 Weld）在依赖注入上也使用该规范。","title":"使用Guice管理类依赖"},{"location":"/engineering/guice.html#jsr-330","text":"","title":"JSR-330"},{"location":"/engineering/guice.html#javax-inject","text":"javax.inject包指定了获取、实例化对象的方法，该方法与构造器、工厂以及命名服务查找（例如JNDI）这些传统方法相比可以获得更好的可重用性、可测试性以及可维护性。\n通常在程序中，很多类型需要依赖于其它类型。例如，一个Stopwatch类可能依赖地一个TimeSource。一些类型补另一个类型依赖，我们就把这些类型叫做这个类型的 依赖（物）。在运行时查找一个依赖实例的过程叫做 依赖解析。如何找不到依赖的实例，那我们称该依赖为 不能满足，并导致应用运行失败。\n在不使用依赖注入时，对象的依赖解析有多种方式。最常见的就是通过在构造器内直接硬编码实现：\nclass Stopwatch {\n    final TimeSource timeSource;\n\n    Stopwatch() {\n        timeSource = new AtomicClocl();\n    }\n\n    void start() { .... }\n\n\n    long stop() { .... }\n}\n若需要更有弹性一点，那么可能通过工厂或服务查询的方式实现。\nclass Stopwatch {\n    final TimeSource timeSource;\n\n    Stopwatch() {\n        timeSource = TimeSourceFactory.getInstance();\n    }\n\n    // ....\n}\n这种方式是不可重用的，且可测试性非常低，也不利于代码的维护。而 依赖注入 就是为了解决这类问题。代替程序员调用构造器或工厂，一个称作 依赖注入器 的工具将把依赖传递给对象：\nclass Stopwatch @Inject()(timeSource: TimeSource) {\n  def start(): Unit = { .... }\n\n  def stop(): Long = { .... }\n}\n注入器将更进一步地传递依赖给其他的依赖，直到它构造出整个对象图。如：\nclass StopwatchWidget @Inject()(sw: Stopwatch) {\n  // ....\n}\n注入器可能的操作为：\n查找一个TimeSource实例 使用找到的TimeSource实例构造一个Stopwatch 使用构造的Stopwatch实例构造一个StopwatchWidget\n这可以使用我们的代码保持干净。同时，在单元测试时，可以直接将模拟对象传入构造器（不使用依赖注入框架）。\ndef testStopwatch() {\n  val sw = new Stopwatch(new MockTimeSource())\n}\n在javax.inject中提供了一些注解来简化我们使用依赖注入。","title":"javax.inject"},{"location":"/engineering/guice.html#inject","text":"注解@Inject标识了可注入的构造器、方法或属性字段。可以用于静态或实例成员，一个可注入的成员可以被任何访问修饰符进行修饰（private、package-private、protected、public）。注入的顺序为构造器、属性字段、方法。超类的属性、方法将优先于子类的属性、方法被注入。对于同一个类的属性是不区分注入顺序的，同一个类的方法亦一样。\n对于每一个类，@Inject最多只允许对一个构造器进行标注（Scala一般是在主构造器上标注）。\n当一个方法标注了@Inject并覆写了基类标注了@Inject的方法时，对于每一个实例可注入一次。当一个方法没有标注@Inject并覆写了基类标注了@Inject的方法时，依赖注入框架不会对此方法进行注入。\n注意 在Scala中，若使用构造器注入。需要使用@Inject()，它和Java里面直接写@Inject不一样。 当使用属性字段注入时，属性通常使用var定义。","title":"@Inject"},{"location":"/appendix/index.html","text":"","title":"附录"},{"location":"/appendix/index.html#附录","text":"参考资料 专业术语 词汇表","title":"附录"},{"location":"/appendix/appendix.0.html","text":"","title":"参考资料"},{"location":"/appendix/appendix.0.html#参考资料","text":"Akka Doc: http://doc.akka.io/docs/akka/2.4/scala.html Akka HTTP doc: http://doc.akka.io/docs/akka-http/current/scala/http/ 《Akka in Action》：https://www.manning.com/books/akka-in-action 《响应式架构：消息模式Actor实现与Scala、Akka应用集成》：http://product.china-pub.com/4970527","title":"参考资料"},{"location":"/appendix/appendix.1.html","text":"","title":"专业术语"},{"location":"/appendix/appendix.1.html#专业术语","text":"trait：特征，可以比做是具有方法实现和属性的接口。","title":"专业术语"},{"location":"/appendix/appendix.2.html","text":"","title":"词汇表"},{"location":"/appendix/appendix.2.html#词汇表","text":"","title":"词汇表"},{"location":"/donate.html","text":"","title":"赞助"},{"location":"/donate.html#赞助","text":"若您觉得本书写得还不错，谢谢赞助作者：\n支付宝 微信","title":"赞助"},{"location":"/routing-dsl/common-directive.html","text":"","title":"常用指令（Directives）"},{"location":"/routing-dsl/common-directive.html#常用指令-directives-","text":"","title":"常用指令（Directives）"},{"location":"/routing-dsl/common-directive.html#methoddirectives","text":"HTTP方法指令用于匹配HTTP method，当请求不符合时将被拒绝，并返回 405 Method Not Allowed。常用预定义指令有：\nget：匹配HTTP的GET方法 post：匹配HTTP的POST方法 put：匹配HTTP的PUT方法 delete：匹配HTTP的DELETE方法","title":"MethodDirectives"},{"location":"/routing-dsl/common-directive.html#抽取httpmethod","text":"除了在路由上匹配某个HTTP方法外，我们还可以抽取方法（HttpMethod），这个使用 def extractMethod: Directive1[HttpMethod]指令。示例如下：\nval route =\n  get {\n    complete(\"This is a GET request.\")\n  } ~\n    extractMethod { method =>\n      complete(s\"This ${method.name} request, clearly is not a GET!\")\n    }\n\n// tests:\nGet(\"/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"This is a GET request.\"\n}\n\nPut(\"/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"This PUT request, clearly is not a GET!\"\n}\nHead(\"/\") ~> route ~> check {\n  responseAs[String] shouldEqual \"This HEAD request, clearly is not a GET!\"\n}","title":"抽取HttpMethod"},{"location":"/routing-dsl/common-directive.html#自定义httpmethod","text":"当你需要使用非标准的Http方法时，可以通过HttpMethod.custom来自定义。\nimport akka.http.scaladsl.settings.{ ParserSettings, ServerSettings }\n\n// 自定义HTTP方法:\nval BOLT = HttpMethod.custom(\"BOLT\", safe = false,\n  idempotent = true, requestEntityAcceptance = Expected)\n\n// 添加自定义方法到设置里\nval parserSettings = ParserSettings(system).withCustomMethods(BOLT)\nval serverSettings = ServerSettings(system).withParserSettings(parserSettings)\n\nval routes = extractMethod { method =>\n  complete(s\"This is a ${method.name} method request.\")\n}\nval binding = Http().bindAndHandle(routes, host, port, settings = serverSettings)\n\nval request = HttpRequest(BOLT, s\"http://$host:$port/\", protocol = `HTTP/1.1`)","title":"自定义HttpMethod"},{"location":"/routing-dsl/common-directive.html#overridemethodwithparameter","text":"def overrideMethodWithParameter(paramName: String): Directive0\noverrideMethodWithParameter指令可以通过指定的请求参数来改变HttpRequest保存的请求HTTP方法。这在一些遗留项目或特殊环境下有用。比如：某些网络环境不支持DELETE、PUT方法，就可以通过如下的方式将一个带特定参数的请求转换成对应的DELETE或PUT请求。\nval route =\n  overrideMethodWithParameter(\"method\") {\n    get {\n      complete(\"This looks like a GET request.\")\n    } ~\n      post {\n        complete(\"This looks like a POST request.\")\n      }\n  }\n\n// tests:\nGet(\"/?method=POST\") ~> route ~> check {\n  responseAs[String] shouldEqual \"This looks like a POST request.\"\n}\nPost(\"/?method=get\") ~> route ~> check {\n  responseAs[String] shouldEqual \"This looks like a GET request.\"\n}\n\nGet(\"/?method=hallo\") ~> route ~> check {\n  status shouldEqual StatusCodes.NotImplemented\n}","title":"overrideMethodWithParameter"},{"location":"/routing-dsl/common-directive.html#parameterdirectives-formfielddirectives","text":"TODO","title":"ParameterDirectives，FormFieldDirectives"},{"location":"/routing-dsl/common-directive.html#marshallingdirectives","text":"TODO","title":"MarshallingDirectives"},{"location":"/routing-dsl/common-directive.html#fileuploaddirectives","text":"TODO","title":"FileUploadDirectives"},{"location":"/routing-dsl/common-directive.html#cookiedirectives","text":"TODO","title":"CookieDirectives"},{"location":"/examples/example.html","text":"val HEADER_KEYS = Set(\"api-id\", \"user-id\", \"org-id\")\n\n  def generateHeaders: Directive1[Map[String, String]] =\n    extractRequest.flatMap { request =>\n      val headerMap = request.headers\n        .filter(header => HEADER_KEYS.contains(header.lowercaseName()))\n        .map(header => header.lowercaseName() -> header.value())\n        .toMap\n      if (true) provide(headerMap)\n      else reject(ForbiddenRejection(\"用户认证失败\"))\n    }\n\n  def testRoute = generateHeaders { reqHeaders =>\n    messageRoute(reqHeaders)\n  }\n\n  def messageRoute(reqHeaders: Map[String, String]): Route = {\n    completeOk\n  }","title":""}]}